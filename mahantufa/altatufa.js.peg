// This is a Parsing Expression Grammar for Lojban.
// See http://bford.info/packrat/
// 
// All rules have the form:
// 
// 	name = peg_expression
// 
// which means that the grammatical construct "name" is parsed using
// "peg_expression".  
// 
// 1)  Names in lower case are grammatical constructs.
// 2)  Names in UPPER CASE are selma'o (lexeme) names, and are terminals.
// 3)  Concatenation is expressed by juxtaposition with no operator symbol.
// 4)  / represents *ORDERED* alternation (choice).  If the first
//      option succeeds, the others will never be checked.
// 5)  ? indicates that the element to the left is optional.
// 6)  * represents optional repetition of the construct to the left.
// 7)  + represents one_or_more repetition of the construct to the left.
// 8)  () serves to indicate the grouping of the other operators.
//
// Longest match wins.
// How to compile using Node.js: (Added by Masato Hagiwara)

// // load peg.js and the file system module
// > var PEG = require("pegjs")
// > var fs = require("fs")
// // read peg and build a parser
// > var camxes_peg = fs.readFileSync("/path/to/camxes.js.peg").toString();
// > var camxes = PEG.buildParser(camxes_peg, {cache: true});
// // test it
// > camxes.parse("ko'a broda");
// [ 'text',
//   [ 'NIhO_node',
//     [ 'paragraphs', [Object] ] ] ]
// // write to a file
// > fs.writeFileSync("/path/to/camxes.js", camxes.toSource());


// ___ GRAMMAR ___

{
  var _g_zoi_delim;
  function _join(arg)
  {
    if (typeof(arg) == "string")
      return arg;
    else
    {
      var ret = "";
      for (var v in arg) { ret += _join(arg[v]); }
      return ret;
    }
  }

  function _node(label, arg)
  {
    var ret = [];
    if (label != undefined) ret.push( label );
    if (typeof( arg ) == "object" && typeof( arg[0] ) == "string" && arg[0] != "")
    {
      ret.push( arg );
      return ret;
    }
    return _node_int(label, arg);
  } 

  function _node_int(label, arg)
  {
    if (typeof( arg ) == "string")
      return arg;
    var ret = [];
    if (label != undefined) ret.push( label );
    for (var v in arg)
    {
      if (arg[v].length != 0)
        ret.push( _node_int( undefined, arg[v] ) );
    }
    return ret;
  }
 
  function _node2(label, arg1, arg2)
  {
    return [label].concat(_node(arg1)).concat(_node(arg2));
  }

  function _node_nonempty(label, arg)
  {
    var _n = _node(label, arg);
    return (_n.length == 1 && _n[0] == label) ? [] : _n;
  }
  
  // === ZOI functions === //

  function _zoi_assign_delim(word) {
	var a = word.toString().split(",");
	if (a.length > 0) _g_zoi_delim = a[a.length - 1];
	else _g_zoi_delim = "";
	return word;
  }

  function _zoi_check_quote(word) {
	if (typeof(word) == "object") word = word.toString();
    if (!is_string(word)) {
	  alert("ZOI word is not a string");
	  return false;
	} else {
      return (word.toLowerCase().replace(/,/gm,"").replace(/h/g, "'") === _g_zoi_delim);
	}
  }
  
  function _zoi_check_delim(word) {
	if (typeof(word) == "object") word = word.toString();
    if (!is_string(word)) {
	  alert("ZOI word is not a string");
	  return false;
	} else {
	  word = word.split(",");
	  if (word.length > 0) word = word[word.length - 1];
	  else word = "";
      return (word === _g_zoi_delim);
	}
  }
  
  function is_string(v) {
    return typeof v.valueOf() === 'string';
  }
}

// PARAGRAPHING
text = expr:(intro_null nion_0 intro_si_clause faho_clause EOF?) {return _node_nonempty("text", expr);}
nion_0 = expr:((NIhO_elided !NIhO_clause)? nion) {return _node("paragraph1", expr);}
nion = expr:((NIhO_clause nion)+ / ion) {return _node("paragraph", expr);}
ion = expr:((I_clause_elidible bridi_elided (ijobon / ijon) / I_clause_elidible bridi_ext (&I_clause ijon)*) (I_clause bridi_ext)*) {return _node("sentence", expr);}
bridi_ext = expr:(tagBAM? TUhE_space / subbridi (&I_clause ijobon)*){return _node("subsentence", expr);}
TUhE_space = expr:(TUhE_clause full_INT* nion_0 TUhU_elidible full_INT*) {return _node("TUhE_scope", expr);}
ijon = expr:(I_clause_elidible je su_clause* bridi_ext) {return _node("ijon", expr);}
ijobon = expr:(I_clause_elidible jebo su_clause* bridi_ext) {return _node("ijobon", expr);}
NIhO_elided = {return ["NIhO_elided", "NIhO"];}
intro_null = expr:(spaces? su_clause*) {return _node_nonempty("intro_null", expr); }
intro_si_clause = expr:(si_clause? SI*)  {return _node_nonempty("intro_si_clause", expr); }
faho_clause = expr:((FAhO_clause dot_star)?) {return _node("faho_clause", expr);}

// INTERJECTIONS
full_INT = expr:(FUhE_clause? (INT_root  INT_suffix? / INT_root_elided INT_suffix)+ FUhO_clause?){return _node("full interjection", expr); }
INT_root = expr:(UI_clause !BU_clause full_NAICAI? / free){return _node("interjection root", expr); }
INT_suffix = expr:((DAI_clause !BU_clause full_NAICAI?)+){return _node("interjection categorizer", expr); }
INT_root_elided = expr:(JUhA_elided_clause !BU_clause){return _node("interjection root elided", expr); }
free = expr:(SEI_clause bridi_sei SEhU_elidible / vocative (sumti_le_elidible / sumtido) DOhU_elidible / mex MAI_clause / TO_clause text TOI_elidible / xi_clause / LOhAI_clause) {return _node("free", expr); }
free_xohe = expr:(mex_2_xohe MAI_clause) {return _node("free", expr); }
xi_clause = expr:(XI_clause mex) {return _node("xi_clause", expr); }
vocative = expr:((COI_clause full_NAICAI?) full_INT*)  {return _node("vocative", expr); }

// SCALERS
full_NAICAI = expr:(CAI_clause !BU_clause full_NAICAI*) {return _node("right scaler", expr); }
full_NAhE = expr:(NAhE_clause) {return _node("left scaler", expr); }
LAhE_NAhE = expr:(LAhE_clause / NAhE_clause BO_clause) {return _node("left metonimizer", expr); }


// FRAGMENTS
//todo: implement fragments
//fragment = expr:(!sumsmi !tag mex / links / linkargs) {return _node("fragment", expr);}
//not needed, used only in fragments:
//links = expr:(links_1) {return _node("links", expr);}
//links_1 = expr:((BEI_clause term)+) {return _node("links_1", expr);}


// BRIDI WITH loi FAM je ZAM je BAM sumsmi
bridi = expr:(
(full_INT* loisumsmiBAM? bridi_tailfefifofunoi) / /* klama do ti ta tu vau noi */
normalbridi ) {return _node("bridi", expr);}
normalbridi = expr:(full_INT* (
//(loisumsmiwithzamfafefifofuandmore CU_space bridi_tail) / /* mi [do ti ta tu] (FA ko'a)n klama*///try merging with ^CU
//(loisumsmiwithzamfafefifofu CU_space bridi_tail) / /* mi do ti ta tu klama*/
//(loisumsmiwithzamfafefifo CU_space bridi_tailfu) / /* mi do ti ta klama tu*/
//(loisumsmiwithzamfafefi CU_space bridi_tailfofu) / /* mi do ti klama ta tu*/
//(loisumsmiwithzamfafe CU_space bridi_tailfifofu) / /* mi do klama ti ta tu*/
//(loisumsmiwithzamfa CU_space bridi_tailfefifofu) / /* mi klama do ti ta tu*/
//(loisumsmiBAM CU_space bridi_tailfefifofu) / /*  caku cu klama do ti ta tu*/
(loisumsmiBFZAM? CU_space)? bridi_tail
))
CU_space = CU_elidible full_INT*

bridi_elided = expr:(loisumsmiBAM bridi_tailfefifofu_elided) {return _node("bridi_elided", expr);}
bridi_sei = expr:((loisumsmiBFZAM CU_space)? bridi_tail_nul)  {return _node("bridi_sei", expr);}
//ToDo: add relative clauses, allowing bridi relative clauses using NOI
bridi_tail_nul = expr:(bridi_tail_1_nul) {return _node("bridi_tail_nul", expr);}
bridi_tail_1_nul = expr:(bridi_tail_2_nul) {return _node("bridi_tail_1_nul", expr);}
bridi_tail_2_nul = expr:(bridi_tail_3_nul) {return _node("bridi_tail_2_nul", expr);}
bridi_tail_3_nul = expr:(KE_space_bridi_nul / gek_bridi_tail_nul / (selbri_may_elide / gek_sentence)) {return _node("bridi_tail_3_nul", expr);}
KE_space_bridi_nul = expr:(KE_clause full_INT* !(selbri_2 KEhE) bridi_tail_nul KEhE_elidible full_INT*) {return _node("KE_bridi_nul_scope", expr);}
gek_bridi_tail_nul = expr:(tagBAM_0* (gek bridi_tail_nul gik bridi_tail_nul / KE_space_bridi_nulgek)) {return _node("gek_bridi_tail_nul", expr);}
KE_space_bridi_nulgek = expr:(KE_clause full_INT* gek_bridi_tail_nul KEhE_elidible full_INT*) {return _node("KE_bridi_nul_gek_scope", expr);}

//dont allow joi-ning non-ZAMs with ZAMs?: gek allowed?:
//dont allow joi-ning non-ZAMs with ZAMs?: termset is {ge caku gi baku}:
//```term_no_ZAM = expr:(tag_term_no_ZAM / termset) {return _node("term", expr);}

subbridi = expr:(prenexe* bridi (IAU_clause sumsmiBAM?)?) {return _node("subbridi", expr);}
prenexe = expr:(loisumsmiBFZAM ZOhU_clause) {return _node("prenexe", expr);}
gek_sentence = expr:(tagBAM_0* (gek subbridi gik subbridi tail_loi_sumsmi / KE_space_gek_sentence)) {return _node("gek_sentence", expr);}
KE_space_gek_sentence = expr:(KE_clause full_INT* gek_sentence KEhE_elidible full_INT*) {return _node("KE_space_gek_sentence", expr);}


//BRIDI TAIL
bridi_tail = expr:(bridi_tail_1 (joik_gihek stag? bridi_tail_1)*) {return _node("bridi_tail", expr);}
bridi_tail_1 = expr:(bridi_tail_2 (joik_gihek !(stag? BO_clause) !(stag? KE_clause) CU_space bridi_tail_2)* tail_loi_sumsmi?) {return _node("bridi_tail_1", expr);}
//todo: remove harcoded bo_clauses here
bridi_tail_2 = expr:(bridi_tail_3 ((jebo / joik_gihek stag? BO_clause) CU_space bridi_tail_3 tail_loi_sumsmi)*) {return _node("bridi_tail_2", expr);}
bridi_tail_3 = expr:(KE_space_bridi_tail_3 / loisumsmiBFZAM? (gek_sentence / selbri_may_elide)) {return _node("bridi_tail_3", expr);}
KE_space_bridi_tail_3 = expr:(KE_clause full_INT* !(selbri_2 KEhE) bridi_tail KEhE_elidible full_INT*) {return _node("KE_space_bridi_tail_3", expr);}

gek_bridi_tail = expr:(tagBAM_0* (gek bridi_tail gik bridi_tail / KE_space_gek_bridi_tail)) {return _node("gek_bridi_tail", expr);}
KE_space_gek_bridi_tail = expr:(KE_clause full_INT* gek_bridi_tail KEhE_elidible full_INT*) {return _node("KE_space_gek_bridi_tail", expr);}

//TERMS: BAM, FAM, ZAM
//todo: SOI, "KE_space terms_0 terms_0+ KEhE_elidible"

sumsmiBFAM = expr:(sumsmiBAM / sumsmiFAM) {return _node("loisumsmi", expr);}
sumsmiBFZAM = expr:(sumsmiBAM / sumsmiFAM / sumsmiZAM) {return _node("loisumsmi", expr);}
loisumsmiBFZAM = expr:((KE_space_loisumsmiBFZAM loisumsmiBFZAM? / sumsmiBFZAM / gek loisumsmiBFZAM NUhU_elidible gik loisumsmiBFZAM NUhU_elidible)+) {return _node("loisumsmi", expr);}
KE_space_loisumsmiBFZAM = expr:(KE_clause full_INT* loisumsmiBFZAM KEhE_elidible full_INT*) {return _node("KE_space_loisumsmiBFZAM ", expr);}

loisumsmiBAM = KE_space_loisumsmiBAM loisumsmiBAM? / sumsmiBAM+ / gek loisumsmiBAM NUhU_elidible gik loisumsmiBAM NUhU_elidible
KE_space_loisumsmiBAM = expr:(KE_clause full_INT* loisumsmiBAM KEhE_elidible full_INT*) {return _node("KE_space_loisumsmiBAM ", expr);}
sumsmiBAM = sumsmiBAMprep / sumsmiBAMpostp
sumsmiBAM_0 = sumsmiBAMprep_0 / sumsmiBAMpostp_0 
sumsmiBAM_1 = sumsmiBAMprep_1 / sumsmiBAMpostp_1 

sumsmiBAMprep = expr:(sumsmiBAMprep_0 (joik_jek sumsmiBAM_0)*) {return _node("sumsmi", expr);}
sumsmiBAMprep_0 = expr:(sumsmiBAMprep_1 (jebo sumsmiBAM_1)*) {return _node("sumsmi_0", expr);}
sumsmiBAMprep_1 = expr:(tagBAM_0 (sumti / (KU_clause full_NAICAI? full_INT* / sumtifazohe !bridi_tail))) {return _node("sumsmi_1", expr);}

sumsmiBAMpostp = expr:(sumsmiBAMpostp_0 (joik_jek sumsmiBAM_0)*) {return _node("sumsmi", expr);}
sumsmiBAMpostp_0 = expr:(sumsmiBAMpostp_1 (jebo sumsmiBAM_1)*) {return _node("sumsmi_0", expr);}
sumsmiBAMpostp_1 = expr:(sumti) CO_clause expr2:(tagBAM_0) {return _node("sumsmi_1", expr2.concat(expr));} 

tagBAM_0 = (tagBAM / tagBAMgek) !gik
tagBAMgek = expr:(gek tagBAM gik tagBAM) {return _node("tagBAMgek", expr); }
tagBAM = expr:(tag_headBAM (joik_jek tag_headBAM)*) {return _node("tagBAM", expr); }
tag_headBAM = expr:((full_NAhE cls* tag_rootBAM / cls* tag_rootBAM full_NAICAI?) full_INT*) {return _node("tense_modal", expr); }
tag_rootBAM = NA_clause !kernelo_lo_gihenjoma / BAI_clause / CAhA_clause / CUhE_clause / KI_clause / ZI_clause / PU_clause / VA_clause / FAhA_clause / ZEhA_clause / VEhA_clause / VIhA_clause / mex ROI_clause / TAhE_clause / ZAhO_clause / FIhO_clause selbri FEhU_elidible

loisumsmiFAM = sumsmiFAM+ / gek loisumsmiFAM NUhU_elidible gik loisumsmiFAM NUhU_elidible
sumsmiFAM = sumsmiFAMprep / sumsmiFAMpostp
sumsmiFAM_0 = sumsmiFAMprep_0 / sumsmiFAMpostp_0 
sumsmiFAM_1 = sumsmiFAMprep_1 / sumsmiFAMpostp_1 

sumsmiFAMprep = expr:(sumsmiFAMprep_0 (joik_jek sumsmiFAM_0)*) {return _node("sumsmi", expr);}
sumsmiFAMprep_0 = expr:(sumsmiFAMprep_1 (jebo sumsmiFAM_1)*) {return _node("sumsmi_0", expr);}
sumsmiFAMprep_1 = expr:((tagFAM_0 (sumti / (KU_clause full_NAICAI? full_INT* / sumtifazohe !bridi_tail !gik)))) {return _node("sumsmi_1", expr);}

sumsmiFAMpostp = expr:(sumsmiFAMpostp_0 (joik_jek sumsmiFAM_0)*) {return _node("sumsmi", expr);}
sumsmiFAMpostp_0 = expr:(sumsmiFAMpostp_1 (jebo sumsmiFAM_1)*) {return _node("sumsmi_0", expr);}
sumsmiFAMpostp_1 = expr:(sumti) CO_clause expr2:(tagFAM_0) {return _node("sumsmi_1", expr2.concat(expr));} 

sumsmiFAMprep = expr:((tagFAM_0 (sumti / (KU_clause full_NAICAI? full_INT* / sumtifazohe !bridi_tail))) (joik_jek sumsmiBFAM)*) {return _node("sumsmi", expr);}
sumsmiFAMpostp = expr:(sumti) CO_clause expr2:(tagFAM_0) expr3:((joik_jek sumsmiBFAM)*) {return _node("sumsmi", expr2.concat(expr).concat(expr3));}

tagFAM_0 = (tagFAM / tagFAMgek) !gik
tagFAMgek = expr:(gek tagFAM gik tagFAM) {return _node("tagFAMgek", expr); }
tagFAM = expr:(tag_headFAM (joik_jek tag_headFAM)*) {return _node("tagFAM", expr); }
tag_headFAM = expr:((full_NAhE cls* tag_rootFAM / cls* tag_rootFAM full_NAICAI?) full_INT*) {return _node("tense_modal", expr); }
tag_rootFAM = FA_clause

sumsmiBFAM_0 = sumsmiBAM_0 / sumsmiFAM_0
sumsmiBFAM_1 = sumsmiBAM_1 / sumsmiFAM_1
tagBFAM_0 = tagBAM_0 / tagFAM_0

loisumsmiZAM = sumsmiZAM+ / gek loisumsmiZAM NUhU_elidible gik loisumsmiZAM NUhU_elidible
sumsmiZAM = sumsmiZAMprep
sumsmiZAMprep = expr:(sumsmiZAMprep_0 (joik_jek sumsmiBFAM_0)*) {return _node("sumsmi", expr);}
sumsmiZAMprep_0 = expr:(sumsmiZAMprep_1 (jebo sumsmiBFAM_1)*) {return _node("sumsmi_0", expr);}
sumsmiZAMprep_1 = expr:(tagZAM sumti) {return _node("sumsmi_1", expr);}
tagZAM = expr:(tag_headZAM (joik_jek tag_headZAM)*) {return _node("tagZAM", expr); }
tag_headZAM = expr:((tag_rootZAM)) {return _node("tense_modal", expr); }
tag_rootZAM = FA_clause_elided

//todo://jebo not done
loisumsmiwithzamfa = loisumsmiBAM? sumsmiZAMfa loisumsmiBAM?
sumsmiZAMfa = expr:((!gek tagZAMfa sumti) (joik_jek sumsmiBFAM)*) {return _node("sumsmi", expr);}
tagZAMfa = expr:(tag_headZAMfa (joik_jek tag_headZAMfa)*) {return _node("tagZAM", expr); }
tag_headZAMfa = expr:((tag_rootZAMfa)) {return _node("tense_modal", expr); }
tag_rootZAMfa = FAXIPA_clause_elided

loisumsmiwithzamfe = loisumsmiBAM? sumsmiZAMfe loisumsmiBAM?
sumsmiZAMfe = expr:((!gek tagZAMfe sumti) (joik_jek sumsmiBFAM)*) {return _node("sumsmi", expr);}
tagZAMfe = expr:(tag_headZAMfe (joik_jek tag_headZAMfe)*) {return _node("tagZAM", expr); }
tag_headZAMfe = expr:((tag_rootZAMfe)) {return _node("tense_modal", expr); }
tag_rootZAMfe = FAXIRE_clause_elided

loisumsmiwithzamfi = loisumsmiBAM? sumsmiZAMfi loisumsmiBAM?
sumsmiZAMfi = expr:((!gek tagZAMfi sumti) (joik_jek sumsmiBFAM)*) {return _node("sumsmi", expr);}
tagZAMfi = expr:(tag_headZAMfi (joik_jek tag_headZAMfi)*) {return _node("tagZAM", expr); }
tag_headZAMfi = expr:((tag_rootZAMfi)) {return _node("tense_modal", expr); }
tag_rootZAMfi = FAXICI_clause_elided

loisumsmiwithzamfo = loisumsmiBAM? sumsmiZAMfo loisumsmiBAM?
sumsmiZAMfo = expr:((!gek tagZAMfo sumti) (joik_jek sumsmiBFAM)*) {return _node("sumsmi", expr);}
tagZAMfo = expr:(tag_headZAMfo (joik_jek tag_headZAMfo)*) {return _node("tagZAM", expr); }
tag_headZAMfo = expr:((tag_rootZAMfo)) {return _node("tense_modal", expr); }
tag_rootZAMfo = FAXIVO_clause_elided

loisumsmiwithzamfu = loisumsmiBAM? sumsmiZAMfu loisumsmiBAM?
sumsmiZAMfu = expr:((!gek tagZAMfu sumti) (joik_jek sumsmiBFAM)*) {return _node("sumsmi", expr);}
tagZAMfu = expr:(tag_headZAMfu (joik_jek tag_headZAMfu)*) {return _node("tagZAM", expr); }
tag_headZAMfu = expr:((tag_rootZAMfu)) {return _node("tense_modal", expr); }
tag_rootZAMfu = FAXIMU_clause_elided

loisumsmiwithzamfafe = loisumsmiwithzamfa sumsmiZAMfe loisumsmiBAM?
loisumsmiwithzamfafefi = loisumsmiwithzamfafe sumsmiZAMfi loisumsmiBAM?
loisumsmiwithzamfafefifo = loisumsmiwithzamfafefi sumsmiZAMfo loisumsmiBAM?
loisumsmiwithzamfafefifofu = loisumsmiwithzamfafefifo sumsmiZAMfu loisumsmiBAM?
loisumsmiwithzamfafefifofuandmore = loisumsmiwithzamfafefifofu loisumsmiBFZAM

tail_might_have_loisumsmizamfa = expr:(loisumsmiwithzamfa? vaunotbeforezohu) {return _node_nonempty("tail_termsZAMfu", expr); }
tail_might_have_loisumsmizamfe = expr:(loisumsmiwithzamfe? vaunotbeforezohu) {return _node_nonempty("tail_termsZAMfu", expr); }
tail_might_have_loisumsmizamfi = expr:(loisumsmiwithzamfi? vaunotbeforezohu) {return _node_nonempty("tail_termsZAMfu", expr); }
tail_might_have_loisumsmizamfo = expr:(loisumsmiwithzamfo? vaunotbeforezohu) {return _node_nonempty("tail_termsZAMfu", expr); }
tail_might_have_loisumsmizamfu = expr:(loisumsmiwithzamfu? vaunotbeforezohu) {return _node_nonempty("tail_termsZAMfu", expr); }
zamfofu = loisumsmiwithzamfo loisumsmiwithzamfu?
zamfifofu = loisumsmiwithzamfi zamfofu?
zamfefifofu = loisumsmiwithzamfe zamfifofu?
vaunotbeforezohu = VAU_elidible  !ZOhU_clause
tail_might_have_loisumsmizamfofu = expr:(zamfofu? vaunotbeforezohu) {return _node_nonempty("tail_termsZAMfu", expr); }
tail_might_have_loisumsmizamfifofu = expr:(zamfifofu? vaunotbeforezohu) {return _node_nonempty("tail_termsZAMfu", expr); }
tail_might_have_loisumsmizamfefifofu = expr:(zamfefifofu? vaunotbeforezohu) {return _node_nonempty("tail_termsZAMfu", expr); }
tail_might_have_loisumsmizamfefifofunoi = expr:(zamfefifofunoi vaunotbeforezohu) {return _node_nonempty("tail_termsZAMnoi", expr); }

zamfefifofunoi = loisumsmiwithzamfanoi

loisumsmiwithzamfanoi = loisumsmiBAM? sumsmiZAMfanoi loisumsmiBAM?
sumsmiZAMfanoi = expr:((tagZAMfanoi sumtinoi)) {return _node("sumsmi", expr);}
tagZAMfanoi = expr:(tag_headZAMfanoi) {return _node("tagZAM", expr); }
tag_headZAMfanoi = expr:((tag_rootZAMfanoi)) {return _node("tense_modal", expr); }
tag_rootZAMfanoi = FAXIPA_clause_elided

tail_loi_sumsmi = expr:(loisumsmiBFZAM? vaunotbeforezohu) {return _node_nonempty("tail_terms", expr); }

bridi_tailfu = expr:(bridi_tail_1fu (joik_gihek stag? bridi_tail)*) {return _node("bridi_tailfu", expr);}
bridi_tail_1fu = expr:(bridi_tail_2fu (joik_gihek !(stag? BO_clause) !(stag? KE_clause) CU_space bridi_tail_2 tail_loi_sumsmi)*) {return _node("bridi_tail_1", expr);}
bridi_tail_2fu = expr:(bridi_tail_3fu (joik_gihek stag? BO_clause CU_space bridi_tail_3 tail_loi_sumsmi)*) {return _node("bridi_tail_2", expr);}
bridi_tail_3fu = expr:(KE_space_bridi_tail_3fu tail_loi_sumsmi / gek_bridi_tail / (gek_sentence / selbri_may_elide) tail_might_have_loisumsmizamfu ) {return _node("bridi_tail_3", expr);}
KE_space_bridi_tail_3fu = expr:(KE_clause full_INT* !(selbri_2 KEhE) bridi_tail KEhE_elidible full_INT*) {return _node("KE_space_bridi_tail_3fu", expr);}

bridi_tailfofu = expr:(bridi_tail_1fofu (joik_gihek stag? bridi_tail)*) {return _node("bridi_tailfofu", expr);}
bridi_tail_1fofu = expr:(bridi_tail_2fofu (joik_gihek !(stag? BO_clause) !(stag? KE_clause) CU_space bridi_tail_2 tail_loi_sumsmi)*) {return _node("bridi_tail_1", expr);}
bridi_tail_2fofu = expr:(bridi_tail_3fofu (joik_gihek stag? BO_clause CU_space bridi_tail_3 tail_loi_sumsmi)*) {return _node("bridi_tail_2", expr);}
bridi_tail_3fofu = expr:(KE_space_bridi_tail_3fofu tail_loi_sumsmi / gek_bridi_tail / (gek_sentence / selbri_may_elide) tail_might_have_loisumsmizamfofu ) {return _node("bridi_tail_3", expr);}
KE_space_bridi_tail_3fofu = expr:(KE_clause full_INT* !(selbri_2 KEhE) bridi_tail KEhE_elidible full_INT*) {return _node("KE_space_bridi_tail_3fofu", expr);}

bridi_tailfifofu = expr:(bridi_tail_1fifofu (joik_gihek stag? bridi_tail)*) {return _node("bridi_tailfifofu", expr);}
bridi_tail_1fifofu = expr:(bridi_tail_2fifofu (joik_gihek !(stag? BO_clause) !(stag? KE_clause) CU_space bridi_tail_2 tail_loi_sumsmi)*) {return _node("bridi_tail_1", expr);}
bridi_tail_2fifofu = expr:(bridi_tail_3fifofu (joik_gihek stag? BO_clause CU_space bridi_tail_3 tail_loi_sumsmi)*) {return _node("bridi_tail_2", expr);}
bridi_tail_3fifofu = expr:(KE_space_bridi_tail_3fifofu tail_loi_sumsmi/ gek_bridi_tail / (gek_sentence / selbri_may_elide) tail_might_have_loisumsmizamfifofu ) {return _node("bridi_tail_3", expr);}
KE_space_bridi_tail_3fifofu = expr:(KE_clause full_INT* !(selbri_2 KEhE) bridi_tail KEhE_elidible full_INT*) {return _node("KE_space_bridi_tail_3fifofu", expr);}

bridi_tailfefifofu = expr:(bridi_tail_1fefifofu (joik_gihek stag? bridi_tail)*) {return _node("bridi_tailfefifofu", expr);}
bridi_tail_1fefifofu = expr:(bridi_tail_2fefifofu (joik_gihek !(stag? BO_clause) !(stag? KE_clause) CU_space bridi_tail_2 tail_loi_sumsmi)*) {return _node("bridi_tail_1", expr);}
bridi_tail_2fefifofu = expr:(bridi_tail_3fefifofu (joik_gihek stag? BO_clause CU_space bridi_tail_3 tail_loi_sumsmi)*) {return _node("bridi_tail_2", expr);}
bridi_tail_3fefifofu = expr:(KE_space_bridi_tail_3fefifofu tail_loi_sumsmi / gek_bridi_tail / (gek_sentence / selbri_may_elide) tail_might_have_loisumsmizamfefifofu ) {return _node("bridi_tail_3", expr);}
KE_space_bridi_tail_3fefifofu = expr:(KE_clause full_INT* !(selbri_2 KEhE) bridi_tail KEhE_elidible full_INT*) {return _node("KE_space_bridi_tail_3fefifofu", expr);}

bridi_tailfefifofunoi = expr:(bridi_tail_1fefifofunoi) {return _node("bridi_tailfefifofu", expr);}
bridi_tail_1fefifofunoi = expr:(bridi_tail_2fefifofunoi) {return _node("bridi_tail_1fefifofu", expr);}
bridi_tail_2fefifofunoi = expr:(bridi_tail_3fefifofunoi) {return _node("bridi_tail_2fefifofu", expr);}
bridi_tail_3fefifofunoi = expr:(fasnu_to_elide tail_might_have_loisumsmizamfefifofunoi ) {return _node("bridi_tail_3fefifofu", expr);}
//ToDo: are we at the same level up to "fasnu" brivla as normalbridi?:
fasnu_to_elide = expr:(FASNU_elidible) {return _node("selbri", expr); }


bridi_tailfefifofu_elided = expr:(bridi_tail_1fefifofu_elided) {return _node("bridi_tailfefifofu_elided", expr);}
bridi_tail_1fefifofu_elided = expr:(bridi_tail_2fefifofu_elided) {return _node("bridi_tail_1", expr);}
bridi_tail_2fefifofu_elided = expr:(bridi_tail_3fefifofu_elided) {return _node("bridi_tail_2", expr);}
bridi_tail_3fefifofu_elided = expr:(selbri_elided) {return _node("bridi_tail_3", expr);}


//LINKARGs
linkargs = expr:((BE_clause loisumsmiBAM) (BEI_clause sumsmiZAMfe) beifi / (BE_clause sumsmiZAMfe) beifi / BE_clause sumsmiBFZAM (BEI_clause sumsmiBFZAM)* BEhO_elidible full_INT*)  {return _node("linkargs", expr);}
beiBAM = (BEI_clause loisumsmiBAM )*
beifi = beiBAM (BEI_clause sumsmiZAMfi)? beiBAM (BEI_clause sumsmiZAMfo)?  beiBAM (BEI_clause sumsmiZAMfu)? (BEI_clause sumsmiBFZAM)* BEhO_elidible

// SUMTI
//todo: sumti structure is now new
sumtifazohe = expr:(sumti_1fazohe) {return _node("sumti", expr);}
sumti_1fazohe = expr:(sumti_2fazohe) {return _node("sumti_1", expr);}
sumti_2fazohe = expr:(sumti_3fazohe) {return _node("sumti_2", expr);}
sumti_3fazohe = expr:(sumti_4fazohe) {return _node("sumti_3", expr);}
sumti_4fazohe = expr:(sumti_5fazohe) {return _node("sumti_4", expr);}
sumti_5fazohe = expr:(sumti_6fazohe) {return _node("sumti_5", expr);}
sumti_6fazohe = expr:(KOhA_clausefazohe) {return _node("sumti_6", expr);}
KOhA_clausefazohe = pre:KOhA_prefazohe post:post_clause {return _node2("KOhA_clause", pre, post); }
KOhA_prefazohe = pre_clause KOhAfazohe spaces?
KOhAfazohe = { return ["KOhA", "ZOhE"];}

/////End FAM/ZAM/TAM

//SUMTI
//todo: allow NAICAI after sumti
sumti = expr:((KE_space_sumti / gek sumti gik sumti / sumti_1) (VUhO_clause (relative_clauses (joik_jek sumti)?)?)?) {return _node("sumti", expr);}
KE_space_sumti = expr:(KE_clause full_INT* sumti KEhE_elidible full_INT*) {return _node("KE_space_sumti", expr);}

sumti_1 = expr:(sumti_2  (joik_ek sumti_2)*) {return _node("sumti_1", expr);}
sumti_2 = expr:(sumti_3 (jebo full_INT* sumti_3)*) {return _node("sumti_2", expr);}
sumti_3 = expr:(sumti_4_declaration / sumti_4_slice) {return _node("sumti_3", expr);}

sumti_4_declaration = expr:(sumti_5_declaration) {return _node("sumti_4_declaration", expr);}
sumti_5_declaration = expr:((full_NAhE sumti_6_declaration / sumti_6_declaration full_NAICAI?) full_INT* relative_clauses?) {return _node("sumti_5_declaration", expr);}
sumti_6_declaration = expr:(LAhE_NAhE relative_clauses? (sumsmiZAMfe / sumsmiBFAM) LUhU_elidible / RAhOI_clause / ZO_clause / ZOI_clause / ZOhOI_clause / LOhU_space / loi_lerfu BOI_elidible !(BO_clause* full_INT* operand* !(joik_ek sumti) operator) !(operand KEhE) / LU_space / KOhA_clause / li_clause / LE_clause full_INT* se_gadri_be_zo_lo) {return _node("sumti_6_declaration", expr);}
sumti_4_slice = expr:(mex !ROI_clause full_INT* (sumti_5_declaration / sumti_5_slice)) {return _node("sumti_4_slice", expr);}
sumti_5_slice = expr:(sumti_6_slice full_NAICAI? full_INT*) {return _node("sumti_5_slice", expr);}
sumti_6_slice = expr:(se_gadri_be_zo_lo) {return _node("sumti_6_slice", expr);}

LU_space = expr:(LU_clause text LIhU_elidible full_INT*) {return _node("LU_space", expr);}
LOhU_space = expr:(LOhU_clause full_INT*) {return _node("LOhU_space", expr);}
se_gadri_be_zo_lo = (relative_clauses_ne / relative_clauses?) (mex !ROI_clause)? bridi_sei relative_clauses? KU_elidible

//todo: sumti structure is now new
sumtinoi = expr:(sumti_1noi) {return _node("sumti", expr);}
sumti_1noi = expr:(sumti_2noi) {return _node("sumti_1", expr);}
sumti_2noi = expr:(sumti_3noi) {return _node("sumti_2", expr);}
sumti_3noi = expr:(LE_clause_elided sumti_corenoi KU_elidible relative_clauses) {return _node("sumti_3", expr);}
//ToDo: tree lost? check by comparing with non omitted {fasnu fa lo nu ...}:
sumti_corenoi = expr:(bridi_tail_noi) {return _node("sumti_core_noi", expr);}
bridi_tail_noi = expr:(bridi_tail_1_noi) {return _node("bridi_tail_noi", expr);}
bridi_tail_1_noi = expr:(bridi_tail_2_noi) {return _node("bridi_tail_1_noi", expr);}
bridi_tail_2_noi = expr:(bridi_tail_3_noi) {return _node("bridi_tail_2_noi", expr);}
bridi_tail_3_noi = expr:(selbri_noi) {return _node("bridi_tail_3_noi", expr);}
selbri_noi = expr:(selbri_1noi) {return _node("selbri", expr); }
selbri_1noi = expr:(selbri_2noi) {return _node("selbri_1", expr); }
selbri_2noi = expr:(selbri_3noi) {return _node("selbri_2", expr); }
selbri_3noi = expr:(selbri_4nfnoi) {return _node("selbri_3", expr); }
selbri_4nfnoi = expr:(selbri_5nfnoi) {return _node("selbri_4", expr); }
selbri_5nfnoi = expr:(selbri_6nfnoi) {return _node("selbri_5", expr); }
selbri_6nfnoi = expr:(selbrislenfnoi) {return _node("selbri_6", expr); }
selbrislenfnoi = expr:(selbrisle_1nfnoi) {return _node("selbrisle", expr); }
selbrisle_1nfnoi = expr:(selbrisle_2nfnoi &relative_clauses) {return _node("selbrisle_1", expr); }
selbrisle_2nfnoi = expr:(NU_spacenoi) {return _node("selbrisle_2nfnoi", expr); }
NU_spacenoi = expr:(NU_clause_elidible subbridinoi &relative_clauses KEI_elidible full_INT*) {return _node("NU_spacenoi", expr); }
subbridinoi = expr:(prenexe* normalbridi) {return _node("subbridi", expr);}

//todo: sumti structure is now new
sumtido = expr:(sumti_1do) {return _node("sumti", expr);}
sumti_1do = expr:(sumti_2do) {return _node("sumti_1", expr);}
sumti_2do = expr:(sumti_3do) {return _node("sumti_2", expr);}
sumti_3do = expr:(mex? KOhA_clausedo relative_clauses?) {return _node("sumti_3", expr);}


///LE-less sumti
//todo: sumti structure is now new
sumti_le_elidible = expr:(sumti_1 / sumti_1_leless) {return _node("sumti", expr);}
sumti_1_leless = expr:(sumti_2_leless) {return _node("sumti_1", expr);}
sumti_2_leless = expr:(sumti_3_leless) {return _node("sumti_2", expr);}
sumti_3_leless = expr:(LE_clause_elided se_gadri_be_zo_lo full_NAICAI? full_INT* relative_clauses?) {return _node("sumti_3", expr);}

//RAhABRI
relative_clauses = expr:(relative_clause (joik relative_clause)* / gek relative_clauses gik relative_clauses) {return _node("relative_clauses", expr); }
relative_clause = expr:(relative_clause_1) {return _node("relative_clause", expr); }
relative_clause_1 = expr:(GOI_clause full_INT* sumsmiBFZAM? GEhU_elidible full_INT* / NOI_clause full_INT* subbridi KUhO_elidible full_INT*) {return _node("relative_clause_1", expr); }

relative_clauses_ne = expr:( relative_clause_ne (joik (relative_clause / relative_clause_ne))* / gek relative_clauses_ne gik relative_clauses_ne) {return _node("relative_clausesne", expr); }
relative_clause_ne = expr:(relative_clause_1_ne) {return _node("relative_clause", expr); }
relative_clause_1_ne = expr:(GOI_clause_elidible sumsmiZAM GEhU_elidible full_INT*) {return _node("relative_clause_1", expr); }

// SELBRI
//// + Forethought connective
selbri_relative_clauses = expr:(selbri_relative_clause (joik selbri_relative_clause)* / gek selbri_relative_clauses gik selbri_relative_clauses) {return _node("selbri_relative_clauses", expr); }
selbri_relative_clause = expr:(selbri_relative_clause_1) {return _node("selbri_relative_clause", expr); }
selbri_relative_clause_1 = expr:(NOhOI_clause subbridi KUhOI_elidible ) {return _node("selbri_relative_clause_1", expr); }
selbri_relative_clause_start = expr:(NOhOI_clause) {return _node("selbri_relative_clause_start", expr); }

//todo: usually we add  !sumsmiBFZAM after selbri_elided but then maximum stack exceeded
selbri_may_elide = (selbri / selbri_elided)
selbri_elided = expr:(selbri_2_elided) {return _node("selbri", expr); }
selbri_2_elided = expr:(selbri_3_elided) {return _node("selbri_2", expr); }
selbri_3_elided = expr:(selbri_4_elided) {return _node("selbri_3", expr); }
selbri_4_elided = expr:(selbri_5_elided) {return _node("selbri_4", expr); }
selbri_5_elided = expr:(selbri_6_elided) {return _node("selbri_5", expr); }
selbri_6_elided = expr:(selbrisle_elided) {return _node("selbri_6", expr); }
selbrisle_elided = expr:(selbrisle_1_elided) {return _node("selbrisle", expr); }
selbrisle_1_elided = expr:(selbrisle_2_elided) {return _node("selbrisle_1", expr); }
selbrisle_2_elided = expr:(COhE_clause_elided) {return _node("selbrisle_2", expr); }


selbri = expr:(selbri_1 / full_NAhE* guhek selbri_1 gik selbri_1) {return _node("selbri", expr); }
selbri_1 = tagBFAM_0* selbri_2
selbri_2 = expr:(selbri_3 (CO_clause selbri_2)?) {return _node("selbri_2", expr); }
selbri_3 = expr:((selbri_4)+) {return _node("selbri_3", expr); }//todo: restore * selbri_4nf
selbri_4 = expr:(selbri_5 (joik_jek selbri_5 / joik stag? KE_clause selbri_3 KEhE_elidible)*) {return _node("selbri_4", expr); }
selbri_5 = expr:(selbri_6 (jebo selbri_5)?) {return _node("selbri_5", expr); }
selbri_6 = expr:(selbrisle (BO_clause selbri_6)?) {return _node("selbri_6", expr); }
selbrisle = expr:(selbrisle_1 (CEI_clause selbrisle_1)* selbri_relative_clauses?) {return _node("selbrisle", expr); }
selbrisle_1 = expr:(selbrisle_2 linkargs? / linkargs? selbrisle_2) {return _node("selbrisle_1", expr); }

selbri_4nf = expr:(selbri_5nf (joik_jek selbri_5nf / joik stag? KE_clause selbri_3 KEhE_elidible)*) {return _node("selbri_4nf", expr); }
selbri_5nf = expr:(selbri_6nf (jebo selbri_5nf)?) {return _node("selbri_5", expr); }
selbri_6nf = expr:(selbrislenf (BO_clause selbri_6nf)?) {return _node("selbri_6", expr); }
selbrislenf = expr:(selbrisle_1nf (CEI_clause selbrisle_1nf)* selbri_relative_clauses?) {return _node("selbrisle", expr); }
selbrisle_1nf = expr:(selbrisle_2nf linkargs? / linkargs? selbrisle_2nf) {return _node("selbrisle_1nf", expr); }

// ** zei is part of BRIVLA_clause
//SE=JAI
selbrisle_2 = expr:((full_NAhE selbrisle_2_inner / selbrisle_2_inner full_NAICAI?) full_INT*) {return _node("selbrisle_2", expr); }
selbrisle_2_inner = loi_SEJAI_element selbrisle_2 / selbrisle_2_root
selbrisle_2nf = expr:((full_NAhE selbrisle_2nf_inner / selbrisle_2nf_inner full_NAICAI?) full_INT*) {return _node("selbrisle_2nf", expr); }
selbrisle_2nf_inner = loi_SEJAI_element selbrisle_2nf / selbrisle_2_root
selbrisle_2_root = BRIVLA_clause / GOhA_clause RAhO_clause? / KE_space_selbri_3 / ME_clause (sumti / mex) MEhU_elidible MOI_clause? / mex MOI_clause / NUhA_clause operator / NU_space / MEhOI_clause
NU_space = expr:(NU_clause (joik_jek NU_clause)* subbridi KEI_elidible full_INT*) {return _node("NU_spacenoi", expr); }
KE_space_selbri_3 = expr:(KE_clause full_INT* selbri_3 KEhE_elidible full_INT*) {return _node("KE_space_selbri_3", expr);}
loi_SEJAI_element = (SE_clause / JAI_clause (tagBFAM_0+ / tagZAM))+

// MEX
mex = !lerfu_word mex_for_li
mex_for_li = expr:(mex_1 (operator mex_1)*) {return _node("mex", expr); }
mex_1 = expr:(KE_space_mex_2_loi / mex_2_loi ) {return _node("mex_1", expr); }
mex_2_loi = mex_2 (operator BO_clause mex_2)*
KE_space_mex_2_loi = expr:(KE_clause full_INT* mex_2_loi KEhE_elidible full_INT*) {return _node("KE_space_mex_2_loi", expr);}
mex_2 = expr:(operand / mex_rp / mex_forethought) {return _node("mex_2", expr); }
mex_rp = FUhA_clause mex_2+ operator (mex_2* operator)* KUhE_elidible free*
mex_forethought = !(loi_lerfu BOI_elidible) operator mex_2+ mex_forethought? KUhE_elidible / PEhO_clause operator mex_2+ mex_forethought? KUhE_elidible
operator = joik
//operator = expr:(full_NAhE operator / (SE_clause operator / MAhO_clause sumti_le_elidible TEhU_elidible / joik) full_NAICAI?) {return _node("operator", expr); }
operand = expr:(((((PA_clause+ / lerfu_word) BOI_elidible / VEI_clause full_INT* mex VEhO_elidible full_INT* / MOhE_clause sumti_le_elidible TEhU_elidible / LAhE_NAhE mex LUhU_elidible)  full_NAICAI?) / full_NAhE operand) full_INT*) {return _node("operand", expr); }
loi_lerfu = expr:(lerfu_word+) {return _node("loi_lerfu", expr); }
lerfu_word = expr:(PA_clause BY_clause / BY_clause / LAU_clause lerfu_word / TEI_clause loi_lerfu FOI_clause) {return _node("lerfu_word", expr); }

//todo: make like normal mex
mex_2_xohe = expr:(operand_xohe) {return _node("mex_2", expr); }
operand_xohe = expr:((PA_clause_xohe BOI_elidible)  full_NAICAI?) {return _node("operand", expr); }

//todo: merge all mex, PA, letterals and cnima'o here into one
li_clause = expr:(LI_clause ((full_INT / PA_clause / loi_lerfu)+ BOI_elidible / mex_for_li )? LOhO_elidible full_INT*) {return _node("li_clause", expr); }

// TERJONMAhO
gihek = expr:(gihenjoma) {return _node("gihek", expr); }
gihenjoma = expr:((cln cls* kernelo_lo_gihenjoma crn) full_INT*) {return _node("gihenjoma", expr); }
kernelo_lo_gihenjoma = expr:(GI_clause? je / GIhA_clause)
je = (JA_clause / JOI_clause / A_clause / ZIhE_clause / VUhU_clause / MAhO_clause sumti_le_elidible TEhU_elidible)
jebo = (je stag? / stag) BO_clause / CEhE_clause
joik = expr:((cln (full_NAhE / cls)* je crn / interval / GAhO_clause interval  GAhO_clause) full_INT*) {return _node("operator", expr); }
joik_ek = joik
ek = joik
jek = joik
joik_gihek = expr:(joik / gihek ) {return _node("joik_gihek", expr); }

//joik_gihek_elided = expr:(gihek_elided &selbri) {return _node("joik_gihek_elided", expr); }
//gihek_elided = expr:(gihenjoma_elided) {return _node("gihek_elided", expr); }
//gihenjoma_elided = expr:(kernelo_lo_gihenjoma_elided) {return _node("gihenjoma_elided", expr); }
//kernelo_lo_gihenjoma_elided = expr:(GIhA_clause_elided)

interval = expr:(cls* BIhI_clause crn) {return _node("interval", expr); }
joik_jek = joik
gek = expr:((gak cls* joik_jek crn / cls* GA_clause crn / joik GI_clause crn / stag gik) full_INT*) {return _node("gek", expr); }
gak = expr:((ga_clause crn) full_INT*) {return _node("gak", expr); }
guhek = expr:((cls* GUhA_clause crn) full_INT*) {return _node("guhek", expr); }
gik = expr:((GI_clause crn) full_INT*) {return _node("gik", expr); }
stag = tagBAM
crn = expr:(CAI_clause?) {return _node("connective right negator", expr); }
cln = expr:(NA_clause?) {return _node("connective left negator", expr); }
cls = expr:(SE_clause) {return _node("places left switcher", expr); }


// ****************
// Magic Words
// ****************

bu_clause = expr:(pre_clause post:bu_clause_no_pre) {return _node("bu_clause", expr); }
bu_clause_no_pre = expr:((si_word / SU spaces?) bu_tail+ lerfu_post_clause) {return _node("bu_clause_no_pre", expr); }

bu_tail = expr:BU_clause+ {return _node("bu_tail", expr); }

dot_star = expr:(.*) { ret = ""; for (i in expr) ret += (expr[i] === " ") ? "_" : expr[i]; return ret; }

// __ General Morphology Issues
//
// 1.  Spaces (including '.y') and UI are eaten *after* a word.
//
// 3.  BAhE is eaten *before* a word.

// Handling of what can go after a cmavo
//todo: change _node_nonempty to allow <=2 elements
//post_spaces = spaces? !BU_clause
post_clause = expr:(spaces? !BU_clause full_NAICAI? full_INT*) {return _node_nonempty("post_clause", expr); }
post_clause_limited = expr:(spaces? !BU_clause) {return _node_nonempty("post_clause", expr); }
post_clause_for_xohe_mai = expr:(spaces? !BU_clause free_xohe*) {return _node_nonempty("post_clause", expr); }
lerfu_post_clause = expr:(spaces? !BU_clause (!loi_lerfu full_INT)*) {return _node_nonempty("lerfu_post_clause", expr); }

pre_clause = BAhE_clause? si_clause?

// Handling of spaces and things like spaces.
// ___ SPACE ___
// Do *NOT* delete the line above!

// SU clauses
su_clause = (erasable_clause / su_valsi)* SU_clause  {return _node("su_clause", expr); }

// Handling of SI and interactions with zo and lo'u...le'u

si_clause = ((erasable_clause / si_word) si_clause? SI_clause)+

erasable_clause = expr:(bu_clause_no_pre !BU_clause) {return _node("erasable_clause", expr); }

si_word = (CMEVLA / BRIVLA / RAhOI spaces? (initial_rafsi / gismu / CVV_final_rafsi / stressed_initial_rafsi short_final_rafsi) / GOhOI spaces? any_word / ZO spaces? any_word / (LOhAI spaces? (!LOhAI !LEhAI any_word)*)? (LOhAI spaces? (!LOhAI !LEhAI any_word)*)? LEhAI / LOhU spaces? (!LEhU any_word)* LEhU / ZOI spaces? zoi_open spaces? zoi_word* zoi_close / !BU !SI !SU !FAhO CMAVO) spaces?

su_valsi = expr:(si_word / !SU_clause !FAhO_clause any_word spaces?) {return _node("su_valsi", expr); }


// ___ ELIDIBLE FAMYMAHO ___  (EXPERIMENTAL)
FA_clause_elided = {return ["DOhE"];}

BEhO_elidible = expr:(BEhO_clause?) {return (expr == "") ? ["BEhO"] : _node("BEhO", expr);}//+
BOI_elidible = expr:(BOI_clause?)   {return (expr == "") ? ["BOI"]  : _node("BOI", expr);}
CU_elidible = expr:(CU_clause?)     {return (expr == "") ? ["CU"]   : _node("CU", expr);}//+
DOhU_elidible = expr:(DOhU_clause?) {return (expr == "") ? ["DOhU"] : _node("DOhU", expr);}//+
FAXIPA_elidible = expr:((&FA_clause fa)?) {return (expr == "") ? ["FA"] : _node("FA", expr);}
FAXIRE_elidible = expr:((&FA_clause fe)?) {return (expr == "") ? ["FE"] : _node("FA", expr);}
FAXICI_elidible = expr:((&FA_clause fi)?) {return (expr == "") ? ["FI"] : _node("FA", expr);}
FAXIVO_elidible = expr:((&FA_clause fo)?) {return (expr == "") ? ["FO"] : _node("FA", expr);}
FAXIMU_elidible = expr:((&FA_clause fu)?) {return (expr == "") ? ["FU"] : _node("FA", expr);}

FEhU_elidible = expr:(FEhU_clause?) {return (expr == "") ? ["FEhU"] : _node("FEhU", expr);}
// FOI and FUhO are never elidible
GEhU_elidible = expr:(GEhU_clause?) {return (expr == "") ? ["GEhU"] : _node("GEhU", expr);}//+
I_elidible = { return ["I", "I"];}
NE_elidible = { return ["GOI", "NE"];}
KEI_elidible = expr:(KEI_clause?)   {return (expr == "") ? ["KEI"]  : _node("KEI", expr);}//+
KEhE_elidible = expr:(KEhE_clause?) {return (expr == "") ? ["KEhE"] : _node("KEhE", expr);}//+
KU_elidible = expr:(KU_clause?)     {return (expr == "") ? ["KU"]   : _node("KU", expr);}
KUhE_elidible = expr:(KUhE_clause?) {return (expr == "") ? ["KUhE"] : _node("KUhE", expr);}
KUhO_elidible = expr:(KUhO_clause?) {return (expr == "") ? ["KUhO"] : _node("KUhO", expr);}//+
// LEhU is never elidible
//todo: do these elidible break the tree leveling?
LIhU_elidible = expr:(LIhU_clause?) {return (expr == "") ? ["LIhU"] : _node("LIhU", expr);}//+
LOhO_elidible = expr:(LOhO_clause?) {return (expr == "") ? ["LOhO"] : _node("LOhO", expr);}//+
LUhU_elidible = expr:(LUhU_clause?) {return (expr == "") ? ["LUhU"] : _node("LUhU", expr);}//+
MEhU_elidible = expr:(MEhU_clause?) {return (expr == "") ? ["MEhU"] : _node("MEhU", expr);}
NUhU_elidible = expr:(NUhU_clause?) {return (expr == "") ? ["NUhU"] : _node("NUhU", expr);}
SEhU_elidible = expr:(SEhU_clause?) {return (expr == "") ? ["SEhU"] : _node("SEhU", expr);}//+
TEhU_elidible = expr:(TEhU_clause?) {return (expr == "") ? ["TEhU"] : _node("TEhU", expr);}
TOI_elidible = expr:(TOI_clause?)   {return (expr == "") ? ["TOI"]  : _node("TOI", expr);}
TUhU_elidible = expr:(TUhU_clause?) {return (expr == "") ? ["TUhU"] : _node("TUhU", expr);}
VAU_elidible = expr:(VAU_clause?)   {return (expr == "") ? ["VAU"]  : _node("VAU", expr);}
VEhO_elidible = expr:(VEhO_clause?) {return (expr == "") ? ["VEhO"] : _node("VEhO", expr);}//+

FASNU_elidible = {return ["FASNU"] }

NOUNEND = {return ["NF"];}
KUhOI_elidible = expr:(KUhOI_clause?) {return (expr == "") ? ["KUhOI"] : _node("KUhOI", expr);}
KOhA_elided = expr:() { return ["DO", _join(expr)];}
LE_elided = expr:() { return ["LO", _join(expr)];}
PA_elided = expr:() { return ["XOhE", _join(expr)];}
NU_elidible =  expr:() { return ["NU", _join(expr)];}

// ___ SELMAHO ___
// Do *NOT* delete the line above!

BRIVLA_clause = expr:(BRIVLA_pre post:post_clause) {return (expr.length == 2) ? _node2("BRIVLA_clause", expr[0], expr[1]) : _node("BRIVLA_clause", expr[0]); }
BRIVLA_pre = pre_clause BRIVLA spaces?
BRIVLA_clausenf = expr:(BRIVLA_pre BRIVLA_postnf) {return (expr.length == 2) ? _node2("BRIVLA_clausenf", expr[0], expr[1]) : _node("BRIVLA_clausenf", expr[0]); }
BRIVLA_postnf = NOUNEND post_clause

//// EXP-DELETION: brivla/cmevla merge
// CMEVLA_clause = pre:CMEVLA_pre post:CMEVLA_post {return _node2("CMEVLA_clause", pre, post); }
// CMEVLA_pre = pre_clause CMEVLA spaces?
// CMEVLA_post = post_clause

CMAVO_clause = pre:CMAVO_pre post:post_clause {return _node2("CMAVO_clause", pre, post); }
CMAVO_pre = pre_clause CMAVO spaces?

//         eks; basic afterthought logical connectives 
A_clause = pre:A_pre post:post_clause_limited {return _node2("A_clause", pre, post); }
A_pre = pre_clause A spaces?


//         modal operators 
BAI_clause = pre:BAI_pre post:post_clause {return _node2("BAI_clause", pre, post); }
BAI_pre = pre_clause BAI spaces?

//         next word intensifier 
BAhE_clause = expr:(BAhE_pre post:post_clause_limited )+ {return _node("BAhE_clause", expr); }
BAhE_pre = BAhE spaces?

//         sumti link to attach sumti to a selbri 
BE_clause = pre:BE_pre post:post_clause {return _node2("BE_clause", pre, post); }
BE_pre = pre_clause BE spaces?

//         multiple sumti separator between BE, BEI 
BEI_clause = pre:BEI_pre post:post_clause {return _node2("BEI_clause", pre, post); }
BEI_pre = pre_clause BEI spaces?

//         terminates BEBEI specified descriptors 
BEhO_clause = pre:BEhO_pre post:post_clause_limited {return _node2("BEhO_clause", pre, post); }
BEhO_pre = pre_clause BEhO spaces?

//         prefix for high_priority MEX operator
//BIhE_clause = pre:BIhE_pre post:post_clause {return _node2("BIhE_clause", pre, post); }
//BIhE_pre = pre_clause BIhE spaces?

//         interval component of JOI 
BIhI_clause = pre:BIhI_pre post:post_clause {return _node2("BIhI_clause", pre, post); }
BIhI_pre = pre_clause BIhI spaces?

//         joins two units with shortest scope 
BO_clause = pre:BO_pre post:post_clause {return _node2("BO_clause", pre, post); }
BO_pre = pre_clause BO spaces?

//         number / loi_lerfu terminator 
BOI_clause = pre:BOI_pre post:post_clause {return _node2("BOI_clause", pre, post); }
BOI_pre = pre_clause BOI spaces?

//         turns any word into a BY lerfu word 
BU_clause = pre:BU_pre post:BU_post {return _node2("BU_clause", pre, post); }
BU_pre = pre_clause BU spaces?
BU_post = spaces?

//         individual lerfu words 
BY_clause = expr:(BY_pre post:post_clause / bu_clause) {return (expr[0] == "bu_clause") ? ["BY_clause", expr] : _node2("BY_clause", expr[0], expr[1]); }
BY_pre = pre_clause BY spaces?


//         specifies actualitypotentiality of tense 
CAhA_clause = pre:CAhA_pre post:post_clause {return _node2("CAhA_clause", pre, post); }
CAhA_pre = pre_clause CAhA spaces?

//         afterthought intensity marker 
CAI_clause = pre:CAI_pre post:post_clause_limited {return _node2("CAI_clause", pre, post); }
CAI_pre = pre_clause CAI spaces?

//         pro_bridi assignment operator 
CEI_clause = pre:CEI_pre post:post_clause {return _node2("CEI_clause", pre, post); }
CEI_pre = pre_clause CEI spaces?

//         afterthought term list connective 
CEhE_clause = pre:CEhE_pre post:post_clause {return _node2("CEhE_clause", pre, post); }
CEhE_pre = pre_clause CEhE spaces?

//         names; require consonant end, then pause no

//                                    LA or DOI selma'o embedded, pause before if

//                                    vowel initial and preceded by a vowel 

//         tanru inversion  
CO_clause = pre:CO_pre post:post_clause {return _node2("CO_clause", pre, post); }
CO_pre = pre_clause CO spaces?

//         vocative marker
COI_clause = pre:COI_pre post:post_clause {return _node2("COI_clause", pre, post); }
COI_pre = pre_clause COI spaces?

//         vocative marker permitted inside names; must

//                                    always be followed by pause or DOI 

//         separator between head sumti and selbri 
CU_clause = pre:CU_pre post:post_clause_limited {return _node2("CU_clause", pre, post); }
CU_pre = pre_clause (CU spaces?)

//         tensemodal question 
CUhE_clause = pre:CUhE_pre post:post_clause {return _node2("CUhE_clause", pre, post); }
CUhE_pre = pre_clause CUhE spaces?


//         terminator for COI_marked vocatives 
DOhU_clause = pre:DOhU_pre post:post_clause_limited {return _node2("DOhU_clause", pre, post); }
DOhU_pre = pre_clause DOhU spaces?


//         modifier head generic case tag 
FA_clause = pre:FA_pre post:post_clause {return _node2("FA_clause", pre, post); }
FA_pre = pre_clause FA spaces?

FAXIPA_clause_elided = pre:FAXIPA_pre_elided post:post_clause {return _node2("FAXIPA_clause_elided", pre, post); }
FAXIPA_pre_elided = pre_clause FAXIPA_elidible spaces?

FAXIRE_clause_elided = pre:FAXIRE_pre_elided post:post_clause {return _node2("FAXIRE_clause_elided", pre, post); }
FAXIRE_pre_elided = pre_clause FAXIRE_elidible spaces?

FAXICI_clause_elided = pre:FAXICI_pre_elided post:post_clause {return _node2("FAXICI_clause_elided", pre, post); }
FAXICI_pre_elided = pre_clause FAXICI_elidible spaces?

FAXIVO_clause_elided = pre:FAXIVO_pre_elided post:post_clause {return _node2("FAXIVO_clause_elided", pre, post); }
FAXIVO_pre_elided = pre_clause FAXIVO_elidible spaces?

FAXIMU_clause_elided = pre:FAXIMU_pre_elided post:post_clause {return _node2("FAXIMU_clause_elided", pre, post); }
FAXIMU_pre_elided = pre_clause FAXIMU_elidible spaces?


//         superdirections in space 
FAhA_clause = pre:FAhA_pre post:post_clause {return _node2("FAhA_clause", pre, post); }
FAhA_pre = pre_clause FAhA spaces?


//         normally elided 'done pause' to indicate end
//                                    of utterance string 

FAhO_clause = expr:(pre_clause FAhO spaces?) {return _node("FAhO_clause", expr);}

//         ends bridi to modal conversion 
FEhU_clause = pre:FEhU_pre post:post_clause {return _node2("FEhU_clause", pre, post); }
FEhU_pre = pre_clause FEhU spaces?

//         marks bridi to modal conversion 
FIhO_clause = pre:FIhO_pre post:post_clause {return _node2("FIhO_clause", pre, post); }
FIhO_pre = pre_clause FIhO spaces?

//         end compound lerfu 
FOI_clause = pre:FOI_pre post:post_clause {return _node2("FOI_clause", pre, post); }
FOI_pre = pre_clause FOI spaces?

//         reverse Polish flag 
FUhA_clause = pre:FUhA_pre post:post_clause {return _node2("FUhA_clause", pre, post); }
FUhA_pre = pre_clause FUhA spaces?

//         open long scope for indicator 
FUhE_clause = pre:FUhE_pre post:FUhE_post {return _node2("FUhE_clause", pre, post); }
FUhE_pre = pre_clause FUhE spaces?
FUhE_post = !BU_clause spaces? !BU_clause

//         close long scope for indicator 
FUhO_clause = pre:FUhO_pre post:post_clause {return _node2("FUhO_clause", pre, post); }
FUhO_pre = pre_clause FUhO spaces?


//         geks; forethought logical connectives 
GA_clause = pre:GA_pre post:post_clause_limited {return _node2("GA_clause", pre, post); }
GA_pre = pre_clause GA spaces?

ga_clause = pre:ga_pre post:post_clause_limited {return _node2("ga_clause", pre, post); }
ga_pre = pre_clause ga_word spaces?
ga_word = &cmavo expr:( g a ) &post_word {return ["ga_word", _join(expr)];}


//         openclosed interval markers for BIhI 
GAhO_clause = pre:GAhO_pre post:post_clause {return _node2("GAhO_clause", pre, post); }
GAhO_pre = pre_clause GAhO spaces?

//         marker ending GOI relative clauses 
GEhU_clause = pre:GEhU_pre post:post_clause_limited {return _node2("GEhU_clause", pre, post); }
GEhU_pre = pre_clause GEhU spaces?

//         forethought medial marker 
GI_clause = pre:GI_pre post:post_clause_limited {return _node2("GI_clause", pre, post); }
GI_pre = pre_clause GI spaces?

//         logical connectives for bridi_tails 
GIhA_clause = pre:GIhA_pre post:post_clause_limited {return _node2("GIhA_clause", pre, post); }
GIhA_pre = pre_clause GIhA spaces?

GIhA_clause_elided = pre:GIhA_pre_elided post:post_clause_limited {return _node2("GIhA_clause", pre, post); }
GIhA_pre_elided = pre_clause GIhA_elided spaces?

//         attaches a sumti modifier to a sumti 
GOI_clause = pre:GOI_pre post:post_clause_limited {return _node2("GOI_clause", pre, post); }
GOI_pre = pre_clause GOI spaces?
GOI_clause_elidible = pre:GOI_pre_elidible post:post_clause {return _node2("GOI_clause", pre, post); }
GOI_pre_elidible = pre_clause NE_elidible spaces?


//         pro_bridi 
GOhA_clause = pre:GOhA_pre post:post_clause {return _node2("GOhA_clause", pre, post); }
GOhA_pre = pre_clause GOhA spaces?

GOhOI_clause = pre:GOhOI_pre post:post_clause {return _node2("GOhOI_clause", pre, post); }
GOhOI_pre = pre_clause GOhOI spaces? any_word spaces?

COhE_clause_elided = pre:COhE_pre post:post_clause {return _node2("GOhA_clause", pre, post); }
COhE_pre = pre_clause COhE spaces?
COhE = {return ["GOhA", "COhE"];} 

//         GEK for selbrisle, corresponds to JEKs 
GUhA_clause = pre:GUhA_pre post:post_clause_limited {return _node2("GUhA_clause", pre, post); }
GUhA_pre = pre_clause GUhA spaces?


//         sentence link 
I_clause = expr:(I_pre post_clause_for_xohe_mai ) {return _node("I_clause", expr); }
I_pre = pre_clause I spaces?
I_clause_elidible = expr:(I_pre_elidible post_clause_for_xohe_mai ) {return _node("I_clause", expr); }
I_pre_elidible = (pre_clause I / I_elidible) spaces?

IAU_clause = pre:IAU_pre post:post_clause {return _node2("IAU_clause", pre, post); }
IAU_pre = pre_clause IAU spaces?

//         jeks; logical connectives within tanru 
JA_clause = pre:JA_pre post:post_clause_limited {return _node2("JA_clause", pre, post); }
JA_pre = pre_clause JA spaces?

//         modal conversion flag 
JAI_clause = pre:JAI_pre post:post_clause {return _node2("JAI_clause", pre, post); }
JAI_pre = pre_clause JAI spaces?

//         flags an array operand 
JOhI_clause = pre:JOhI_pre post:post_clause {return _node2("JOhI_clause", pre, post); }
JOhI_pre = pre_clause JOhI spaces?

//         non_logical connectives 
JOI_clause = pre:JOI_pre post:post_clause_limited {return _node2("JOI_clause", pre, post); }
JOI_pre = pre_clause JOI spaces?


//         left long scope marker 
KE_clause = pre:KE_pre post:post_clause_limited {return _node2("KE_clause", pre, post); }
KE_pre = pre_clause KE spaces?

//         right terminator for KE groups 
KEhE_clause = pre:KEhE_pre post:post_clause {return _node2("KEhE_clause", pre, post); }
KEhE_pre = pre_clause KEhE spaces?

//         right terminator, NU abstractions 
KEI_clause = pre:KEI_pre post:post_clause_limited {return _node2("KEI_clause", pre, post); }
KEI_pre = pre_clause KEI spaces?

//         multiple utterance scope for tenses 
KI_clause = pre:KI_pre post:post_clause {return _node2("KI_clause", pre, post); }
KI_pre = pre_clause KI spaces?

//         sumti anaphora 
KOhA_clause = pre:KOhA_pre post:post_clause {return _node2("KOhA_clause", pre, post); }
KOhA_pre = pre_clause KOhA spaces?

KOhA_clausedo = pre:KOhA_predo post:post_clause {return _node2("KOhA_clause", pre, post); }
KOhA_predo = pre_clause KOhA_elided spaces?

//         right terminator for descriptions, etc. 
KU_clause = pre:KU_pre post:post_clause_limited {return _node2("KU_clause", pre, post); }
KU_pre = pre_clause KU spaces?

//         MEX forethought delimiter 
KUhE_clause = pre:KUhE_pre post:post_clause {return _node2("KUhE_clause", pre, post); }
KUhE_pre = pre_clause KUhE spaces?

//         right terminator, NOI relative clauses 
KUhO_clause = pre:KUhO_pre post:post_clause_limited {return _node2("KUhO_clause", pre, post); }
KUhO_pre = pre_clause KUhO spaces?

//// EXP-DELETION: brivla/cmevla merge
//         name descriptors 
// LA_clause = pre:LA_pre post:post_clause {return _node2("LA_clause", pre, post); }
// LA_pre = pre_clause LA spaces?

//         lerfu prefixes 
LAU_clause = pre:LAU_pre post:post_clause {return _node2("LAU_clause", pre, post); }
LAU_pre = pre_clause LAU spaces?

//         sumti qualifiers 
LAhE_clause = pre:LAhE_pre post:post_clause {return _node2("LAhE_clause", pre, post); }
LAhE_pre = pre_clause LAhE spaces?

//         sumti descriptors 
LE_clause = pre:LE_pre post:post_clause_limited {return _node2("LE_clause", pre, post); }
LE_pre = pre_clause LE spaces?

LE_clause_elided = pre:LE_pre_elided post:post_clause {return _node2("LE_clause", pre, post); }
LE_pre_elided = pre_clause LE_elided spaces?


//         possibly ungrammatical text right quote 
LEhU_clause = pre:LEhU_pre post:LEhU_post {return _node2("LEhU_clause", pre, post); }
LEhU_pre = pre_clause LEhU spaces?
LEhU_post = spaces?

//         convert number to sumti 
LI_clause = pre:LI_pre post:post_clause_limited {return _node2("LI_clause", pre, post); }
LI_pre = pre_clause LI spaces?

//         grammatical text right quote 
LIhU_clause = pre:LIhU_pre post:post_clause {return _node2("LIhU_clause", pre, post); }
LIhU_pre = pre_clause LIhU spaces?

//         elidable terminator for LI 
LOhO_clause = pre:LOhO_pre post:post_clause_limited {return _node2("LOhO_clause", pre, post); }
LOhO_pre = pre_clause LOhO spaces?

//         possibly ungrammatical text left quote 
LOhU_clause = pre:LOhU_pre post:post_clause_limited {return _node2("LOhU_clause", pre, post); }
LOhU_pre = pre_clause LOhU spaces? (!LEhU any_word)* LEhU_clause spaces?

// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
//         possibly ungrammatical replacement expression
LOhAI_clause = pre:LOhAI_pre post:post_clause {return _node2("LOhAI_clause", pre, post); }
LOhAI_pre = pre_clause (LOhAI spaces? (!LOhAI !LEhAI any_word)*)? (LOhAI spaces? (!LOhAI !LEhAI any_word)*)? LEhAI spaces?

//         grammatical text left quote 
LU_clause = pre:LU_pre post:post_clause_limited {return _node2("LU_clause", pre, post); }
LU_pre = pre_clause LU spaces?

//         LAhE close delimiter 
LUhU_clause = pre:LUhU_pre post:post_clause_limited {return _node2("LUhU_clause", pre, post); }
LUhU_pre = pre_clause LUhU spaces?

//         change numbers to utterance ordinals 
MAI_clause = pre:MAI_pre post:post_clause_limited {return _node2("MAI_clause", pre, post); }
MAI_pre = pre_clause MAI spaces?

//         converts a sumti into a selbrisle 
ME_clause = pre:ME_pre post:post_clause {return _node2("ME_clause", pre, post); }
ME_pre = pre_clause ME spaces?

//         terminator for ME 
MEhU_clause = pre:MEhU_pre post:post_clause {return _node2("MEhU_clause", pre, post); }
MEhU_pre = pre_clause MEhU spaces?

//         change sumti to operand, inverse of LI, change selbri to operand; inverse of MOI 
MOhE_clause = pre:MOhE_pre post:post_clause {return _node2("MOhE_clause", pre, post); }
MOhE_pre = pre_clause MOhE spaces?

//         change number to selbri 
MOI_clause = pre:MOI_pre post:post_clause {return _node2("MOI_clause", pre, post); }
MOI_pre = pre_clause MOI spaces?


//         bridi negation  
//ToDo: post clause is limited in {na gi'e}?
NA_clause = pre:NA_pre post:post_clause {return _node2("NA_clause", pre, post); }
NA_pre = pre_clause NA spaces?


//         scalar negation  
NAhE_clause = pre:NAhE_pre post:post_clause {return _node2("NAhE_clause", pre, post); }
NAhE_pre = pre_clause NAhE spaces?

//         change a selbri into an operator 
MAhO_clause = pre:MAhO_pre post:post_clause {return _node2("MAhO_clause", pre, post); }
MAhO_pre = pre_clause MAhO spaces?

//         new paragraph; change of subject 
NIhO_clause = expr:(NIhO_pre NIhO_post) {return _node("NIhO_clause", expr); }
NIhO_pre = pre_clause NIhO spaces?
NIhO_post = su_clause* post_clause
NIhO_clause_elided = pre:NIhO_pre_elided post:NIhO_post {return _node2("NIhO_clause", pre, post); }
NIhO_pre_elided = pre_clause NIhO_elided spaces?

//         attaches a subordinate clause to a sumti 
NOI_clause = pre:NOI_pre post:post_clause_limited {return _node2("NOI_clause", pre, post); }
NOI_pre = pre_clause NOI spaces?

//         abstraction  
NU_clause = pre:NU_pre post:post_clause {return _node2("NU_clause", pre, post); }
NU_pre = pre_clause NU spaces?
NU_clause_elidible = pre:NU_pre_elidible post:post_clause {return _node2("NU_clause", pre, post); }
NU_pre_elidible = pre_clause NU_elidible spaces?

//         change operator to selbri; inverse of MOhE 
NUhA_clause = pre:NUhA_pre post:post_clause {return _node2("NUhA_clause", pre, post); }
NUhA_pre = pre_clause NUhA spaces?

//         marks the start of a termset 
NUhI_clause = pre:NUhI_pre post:post_clause {return _node2("NUhI_clause", pre, post); }
NUhI_pre = pre_clause NUhI spaces?

//         marks the middle and end of a termset 
NUhU_clause = pre:NUhU_pre post:post_clause {return _node2("NUhU_clause", pre, post); }
NUhU_pre = pre_clause NUhU spaces?


//         numbers and numeric punctuation 
PA_clause = pre:PA_pre post:post_clause {return _node2("PA_clause", pre, post); }
PA_pre = pre_clause PA spaces?

PA_clause_xohe = pre:PA_xohe_pre post:post_clause {return _node2("PA_clause", pre, post); }
PA_xohe_pre = pre_clause PA_elided spaces?


//         afterthought termset connective prefix 
PEhE_clause = pre:PEhE_pre post:post_clause {return _node2("PEhE_clause", pre, post); }
PEhE_pre = pre_clause PEhE spaces?

//         forethought (Polish) flag 
PEhO_clause = pre:PEhO_pre post:post_clause {return _node2("PEhO_clause", pre, post); }
PEhO_pre = pre_clause PEhO spaces?

//         directions in time 
PU_clause = pre:PU_pre post:post_clause {return _node2("PU_clause", pre, post); }
PU_pre = pre_clause PU spaces?


//         flag for modified interpretation of GOhI 
RAhO_clause = pre:RAhO_pre post:post_clause {return _node2("RAhO_clause", pre, post); }
RAhO_pre = pre_clause RAhO spaces?

RAhOI_clause = pre:RAhOI_pre post:post_clause {return _node2("RAhOI_clause", pre, post); }
RAhOI_pre = pre_clause RAhOI spaces? (initial_rafsi / gismu / CVV_final_rafsi / stressed_initial_rafsi short_final_rafsi) spaces?

//         converts number to extensional tense 
ROI_clause = pre:ROI_pre post:post_clause {return _node2("ROI_clause", pre, post); }
ROI_pre = pre_clause ROI spaces?

//         metalinguistic eraser to the beginning of

//                                    the current utterance 

//         conversions 
SE_clause = pre:SE_pre post:post_clause {return _node2("SE_clause", pre, post); }
SE_pre = pre_clause SE spaces?

//         metalinguistic bridi insert marker 
SEI_clause = pre:SEI_pre post:post_clause {return _node2("SEI_clause", pre, post); }
SEI_pre = pre_clause SEI spaces?

//         metalinguistic bridi end marker 
SEhU_clause = pre:SEhU_pre post:post_clause_limited {return _node2("SEhU_clause", pre, post); }
SEhU_pre = pre_clause SEhU spaces?

//         metalinguistic single word eraser 
SI_clause = expr:(spaces? SI spaces?) {return _node("SI_clause", expr); }

//         EXP: bridi relative clause
SOI_clause = pre:SOI_pre post:post_clause {return _node2("SOI_clause", pre, post); } 
SOI_pre = pre_clause SOI spaces?

//         metalinguistic eraser of the entire text 
SU_clause = pre:SU_pre post:post_clause {return _node2("SU_clause", pre, post); }
SU_pre = pre_clause SU spaces?


//         tense interval properties 
TAhE_clause = pre:TAhE_pre post:post_clause {return _node2("TAhE_clause", pre, post); }
TAhE_pre = pre_clause TAhE spaces?

//         closing gap for MEX constructs 
TEhU_clause = pre:TEhU_pre post:post_clause_limited {return _node2("TEhU_clause", pre, post); }
TEhU_pre = pre_clause TEhU spaces?

//         start compound lerfu 
TEI_clause = pre:TEI_pre post:post_clause {return _node2("TEI_clause", pre, post); }
TEI_pre = pre_clause TEI spaces?

//         left discursive parenthesis 
TO_clause = pre:TO_pre post:post_clause {return _node2("TO_clause", pre, post); }
TO_pre = pre_clause TO spaces?

//         right discursive parenthesis 
TOI_clause = pre:TOI_pre post:post_clause {return _node2("TOI_clause", pre, post); }
TOI_pre = pre_clause TOI spaces?

//         multiple utterance scope mark 
TUhE_clause = pre:TUhE_pre post:TUhE_post {return _node2("TUhE_clause", pre, post); }
TUhE_pre = pre_clause TUhE spaces?
TUhE_post = su_clause* post_clause_limited

//         multiple utterance end scope mark 
TUhU_clause = pre:TUhU_pre post:post_clause {return _node2("TUhU_clause", pre, post); }
TUhU_pre = pre_clause TUhU spaces?


//         attitudinals, observationals, discursives 
UI_clause = pre:UI_pre post:post_clause_limited {return _node2("UI_clause", pre, post); }
UI_pre = pre_clause UI spaces?

DAI_clause = pre:DAI_pre post:post_clause_limited {return _node2("DAI_clause", pre, post); }
DAI_pre = pre_clause DAI spaces?

JUhA_elided_clause = pre:JUhA_elided_pre post:post_clause_limited {return _node2("UI_clause", pre, post); }
JUhA_elided_pre = pre_clause JUhA_elided spaces?

//         distance in space_time 
VA_clause = pre:VA_pre post:post_clause {return _node2("VA_clause", pre, post); }
VA_pre = pre_clause VA spaces?

//         end simple bridi or bridi_tail 
VAU_clause = pre:VAU_pre post:post_clause {return _node2("VAU_clause", pre, post); }
VAU_pre = pre_clause VAU spaces?

//         left MEX bracket 
VEI_clause = pre:VEI_pre post:post_clause_limited {return _node2("VEI_clause", pre, post); }
VEI_pre = pre_clause VEI spaces?

//         right MEX bracket 
VEhO_clause = pre:VEhO_pre post:post_clause_limited {return _node2("VEhO_clause", pre, post); }
VEhO_pre = pre_clause VEhO spaces?

//         MEX operator 
VUhU_clause = pre:VUhU_pre post:post_clause_limited {return _node2("VUhU_clause", pre, post); }
VUhU_pre = pre_clause VUhU spaces?

//         space_time interval size 
VEhA_clause = pre:VEhA_pre post:post_clause {return _node2("VEhA_clause", pre, post); }
VEhA_pre = pre_clause VEhA spaces?

//         space_time dimensionality marker 
VIhA_clause = pre:VIhA_pre post:post_clause {return _node2("VIhA_clause", pre, post); }
VIhA_pre = pre_clause VIhA spaces?

VUhO_clause = pre:VUhO_pre post:post_clause {return _node2("VUhO_clause", pre, post); }
VUhO_pre = pre_clause VUhO spaces?

// glue between logically connected sumti and relative clauses 


//         subscripting operator 
XI_clause = pre:XI_pre post:post_clause {return _node2("XI_clause", pre, post); }
XI_pre = pre_clause XI spaces?


//         hesitation 
// Very very special case.  Handled in the morphology section.
// Y_clause = spaces? Y spaces?


//         event properties _ inchoative, etc. 
ZAhO_clause = pre:ZAhO_pre post:post_clause {return _node2("ZAhO_clause", pre, post); }
ZAhO_pre = pre_clause ZAhO spaces?

//         time interval size tense 
ZEhA_clause = pre:ZEhA_pre post:post_clause {return _node2("ZEhA_clause", pre, post); }
ZEhA_pre = pre_clause ZEhA spaces?

//         time distance tense 
ZI_clause = pre:ZI_pre post:post_clause {return _node2("ZI_clause", pre, post); }
ZI_pre = pre_clause ZI spaces?

//         conjoins relative clauses 
ZIhE_clause = pre:ZIhE_pre post:post_clause_limited {return _node2("ZIhE_clause", pre, post); }
ZIhE_pre = pre_clause ZIhE spaces?

//         single word metalinguistic quote marker 
ZO_clause = pre:ZO_pre post:post_clause {return _node2("ZO_clause", pre, post); }
ZO_pre = pre_clause ZO spaces? any_word spaces?

//         delimited quote marker 
ZOI_clause = pre:ZOI_pre post:post_clause {return _node2("ZOI_clause", pre, post); }
ZOI_pre = pre_clause ZOI spaces? zoi_open spaces? zoi_word* zoi_close spaces?

//         prenexe terminator (not elidable) 
ZOhU_clause = pre:ZOhU_pre post:post_clause_limited {return _node2("ZOhU_clause", pre, post); }
ZOhU_pre = pre_clause ZOhU spaces?

// [EXPERIMENTAL]        single foreign word quote marker 
ZOhOI_clause = pre:ZOhOI_pre post:post_clause {return _node2("ZOhOI_clause", pre, post); }
ZOhOI_pre = pre_clause ZOhOI spaces? zohoi_word spaces?

MEhOI_clause = pre:MEhOI_pre post:post_clause {return _node2("MEhOI_clause", pre, post); }
MEhOI_pre = pre_clause MEhOI spaces? zohoi_word spaces?

NOhOI_clause = pre:NOhOI_pre post:post_clause {return _node2("NOhOI_clause", pre, post); }
NOhOI_pre = pre_clause NOhOI spaces?

KUhOI_clause = pre:KUhOI_pre post:post_clause {return _node2("KUhOI_clause", pre, post); }
KUhOI_pre = pre_clause KUhOI spaces?

// ___ MORPHOLOGY ___

CMEVLA = expr:cmevla {return ["CMEVLA", expr];}
//// EXP-MODIF: brivla/cmevla merge
BRIVLA = expr:(gismu_2 / lujvo / fuhivla / CMEVLA ) {return ["BRIVLA", expr];}
gismu_2 = expr:(gismu) {return ["gismu", expr];}
//// EXP-DEL: LA, for brivla/cmevla merge
// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
CMAVO = expr:(A / BAI / BAhE / BE / BEI / BEhO / BIhI / BO / BOI / BU / BY / CAhA / CAI / CEI / CEhE / CO / COI / CU / CUhE / DOhU / FA / FAhA / FAhO / FEhU / FIhO / FOI / FUhA / FUhE / FUhO / GA / GAhO / GEhU / GI / GIhA / GOI / GOhA / GUhA / I / JA / JAI / JOhI / JOI / KE / KEhE / KEI / KI / KOhA / KU / KUhE / KUhO / LAU / LAhE / LE / LEhAI / LEhU / LI / LIhU / LOhAI / LOhO / LOhU / LU / LUhU / MAI / ME / MEhU / MOhE / MOI / NA / NAhE / MAhO / NIhO / NOI / NU / NUhA / NUhI / NUhU / PA / PEhE / PEhO / PU / RAhO / ROI / SE / SEI / SEhU / SI / SOI / SU / TAhE / TEhU / TEI / TO / TOI / TUhE / TUhU / UI / VA / VAU / VEI / VEhO / VUhU / VEhA / VIhA / VUhO / XI / ZAhO / ZEhA / ZEI / ZI / ZIhE / ZO / ZOI / ZOhU / cmavo) {return ["CMAVO", expr];}

// This is a Parsing Expression Grammar for the morphology of Lojban.
// See http://www.pdos.lcs.mit.edu/~baford/packrat/
//
// All rules have the form
//
// name = peg_expression
//
// which means that the grammatical construct "name" is parsed using
// "peg_expression".
//
// 1) Concatenation is expressed by juxtaposition with no operator symbol.
// 2) / represents *ORDERED* alternation (choice). If the first
// option succeeds, the others will never be checked.
// 3) ? indicates that the element to the left is optional.
// 4) * represents optional repetition of the construct to the left.
// 5) + represents one_or_more repetition of the construct to the left.
// 6) () serves to indicate the grouping of the other operators.
// 7) & indicates that the element to the right must follow (but the
// marked element itself does not absorb anything).
// 8) ! indicates that the element to the right must not follow (the
// marked element itself does not absorb anything).
// 9) . represents any character.
// 10) ' ' or " " represents a literal string.
// 11) [] represents a character class.
//
// Repetitions grab as much as they can.
//
//
// ___ GRAMMAR ___
// This grammar classifies words by their morphological class (cmevla,
// gismu, lujvo, fuhivla, cmavo, and non_lojban_word).
//
//The final section sorts cmavo into grammatical classes (A, BAI, BAhE, ..., ZOhU).
//
// mi'e ((xorxes))

//___________________________________________________________________

// words = expr:(pause? (word pause?)*) { return _join(expr); }

// word = expr:lojban_word / non_lojban_word { return expr; }

// lojban_word = expr:(cmevla / cmavo / brivla) { return expr; }
lojban_word = expr:(CMEVLA / CMAVO / BRIVLA) { return expr; }

any_word = expr:lojban_word spaces? { return expr; }

//// EXP-MODIF: ZOI-fix
zoi_open = w:lojban_word { return _zoi_assign_delim(w); }
zoi_word = expr:( w:(non_space+) spaces &{ return (! _zoi_check_quote(w)); } ) {return "";}
zoi_close = w:lojban_word &{ return (_zoi_check_delim(w)); }

//// EXP-MODIF: ZOhOI/MEhOI implementation
zohoi_word = non_space+ {return "~";} 

//___________________________________________________________________

cmevla = expr:(jbocme / zifcme) { return ["cmevla", _join(expr)]; }

zifcme = (!h (nucleus / glide / h / consonant !pause / digit)* consonant &pause)

jbocme = (&zifcme (any_syllable / digit)* &pause)

//cmevla = !h cmevla_syllable* &consonant coda? consonantal_syllable* onset &pause

//cmevla_syllable = !doi_la_lai_lahi coda? consonantal_syllable* onset nucleus / digit

//doi_la_lai_lahi = (d o i / l a (h? i)?) !h !nucleus

//___________________________________________________________________

cmavo = expr:(!cmevla !CVCy_lujvo cmavo_form &post_word) { return _join(expr); }

CVCy_lujvo = expr:(CVC_rafsi y h? initial_rafsi* brivla_core / stressed_CVC_rafsi y short_final_rafsi) { return _join(expr); }

//cmavo_form = expr:(!h !cluster onset (((a u / a i / e i / o i) H / a Ih &(a / e / o) / (e / o) H &(a / e / o / u) / (i / u) H) &(a / e / i / o / u))+ (nucleus !cluster) / !h !cluster onset (nucleus h)* (!stressed nucleus / nucleus !cluster) / y+ / digit) { return _join(expr); }
cmavo_form = expr:(!h !cluster onset (nucleus h)* (!stressed nucleus / nucleus !cluster) / y+ / digit) { return _join(expr); }

//___________________________________________________________________

brivla = expr:(!cmavo initial_rafsi* brivla_core) { return _join(expr); }

brivla_core = expr:(fuhivla / gismu / CVV_final_rafsi / stressed_initial_rafsi short_final_rafsi) { return _join(expr); }

stressed_initial_rafsi = expr:(stressed_extended_rafsi / stressed_y_rafsi / stressed_y_less_rafsi) { return _join(expr); }

initial_rafsi = expr:(extended_rafsi / y_rafsi / !any_extended_rafsi y_less_rafsi !any_extended_rafsi) { return _join(expr); }

//___________________________________________________________________

any_extended_rafsi = expr:(fuhivla / extended_rafsi / stressed_extended_rafsi) { return _join(expr); }

fuhivla = expr:(fuhivla_head stressed_syllable consonantal_syllable* final_syllable) { return _join(expr); }

stressed_extended_rafsi = expr:(stressed_brivla_rafsi / stressed_fuhivla_rafsi) { return _join(expr); }

extended_rafsi = expr:(brivla_rafsi / fuhivla_rafsi) { return _join(expr); }

stressed_brivla_rafsi = expr:(&unstressed_syllable brivla_head stressed_syllable h y) { return _join(expr); }

brivla_rafsi = expr:(&(syllable consonantal_syllable* syllable) brivla_head h y h?) { return _join(expr); }

stressed_fuhivla_rafsi = expr:(fuhivla_head stressed_syllable &consonant onset y) { return _join(expr); }

fuhivla_rafsi = expr:(&unstressed_syllable fuhivla_head &consonant onset y h?) { return _join(expr); }

fuhivla_head = expr:(!rafsi_string brivla_head) { return _join(expr); }

brivla_head = expr:(!cmavo !slinkuhi !h &onset unstressed_syllable*) { return _join(expr); }

slinkuhi = expr:(!rafsi_string consonant rafsi_string) { return _join(expr); }

rafsi_string = expr:(y_less_rafsi* (gismu / CVV_final_rafsi / stressed_y_less_rafsi short_final_rafsi / y_rafsi / stressed_y_rafsi / stressed_y_less_rafsi? initial_pair y / hy_rafsi / stressed_hy_rafsi)) { return _join(expr); }

//___________________________________________________________________

gismu = expr:((initial_pair stressed_vowel / consonant stressed_vowel consonant) &final_syllable consonant vowel &post_word) { return _join(expr); }

CVV_final_rafsi = expr:(consonant stressed_vowel h &final_syllable vowel &post_word) { return _join(expr); }

short_final_rafsi = expr:(&final_syllable (consonant diphthong / initial_pair vowel) &post_word) { return _join(expr); }

stressed_y_rafsi = expr:((stressed_long_rafsi / stressed_CVC_rafsi) y) { return _join(expr); }

stressed_y_less_rafsi = expr:(stressed_CVC_rafsi !y / stressed_CCV_rafsi / stressed_CVV_rafsi) { return _join(expr); }

stressed_long_rafsi = expr:(initial_pair stressed_vowel consonant / consonant stressed_vowel consonant consonant) { return _join(expr); }

stressed_CVC_rafsi = expr:(consonant stressed_vowel consonant) { return _join(expr); }

stressed_CCV_rafsi = expr:(initial_pair stressed_vowel) { return _join(expr); }

stressed_CVV_rafsi = expr:(consonant (unstressed_vowel h stressed_vowel / stressed_diphthong) r_hyphen?) { return _join(expr); }

y_rafsi = expr:((long_rafsi / CVC_rafsi) y h?) { return _join(expr); }

y_less_rafsi = expr:(!y_rafsi !stressed_y_rafsi !hy_rafsi !stressed_hy_rafsi (CVC_rafsi / CCV_rafsi / CVV_rafsi) !h) { return _join(expr); }

hy_rafsi = expr:((long_rafsi vowel / CCV_rafsi / CVV_rafsi) h y h?)

stressed_hy_rafsi = expr:((long_rafsi stressed_vowel / stressed_CCV_rafsi / stressed_CVV_rafsi) h y h?)

long_rafsi = expr:(initial_pair unstressed_vowel consonant / consonant unstressed_vowel consonant consonant) { return _join(expr); }

CVC_rafsi = expr:(consonant unstressed_vowel consonant) { return _join(expr); }

CCV_rafsi = expr:(initial_pair unstressed_vowel) { return _join(expr); }

CVV_rafsi = expr:(consonant (unstressed_vowel h unstressed_vowel / unstressed_diphthong) r_hyphen?) { return _join(expr); }

r_hyphen = expr:(r &consonant / n &r) { return _join(expr); }

//___________________________________________________________________

final_syllable = expr:(onset !y !stressed nucleus !cmevla &post_word) {return _join(expr);}

stressed_syllable = expr:(&stressed syllable / syllable &stress) {return _join(expr);}

stressed_diphthong = expr:(&stressed diphthong / diphthong &stress) {return _join(expr);}

stressed_vowel = expr:(&stressed vowel / vowel &stress) {return _join(expr);}

unstressed_syllable = expr:(!stressed syllable !stress / consonantal_syllable) {return _join(expr);}

unstressed_diphthong = expr:(!stressed diphthong !stress) {return _join(expr);}

unstressed_vowel = expr:(!stressed vowel !stress) {return _join(expr);}

//// FIX: Xorxes' fix for fu'ivla rafsi stress
stress = expr:(consonant* h? y? syllable pause) {return _join(expr);}

stressed = expr:(onset comma* [AEIOU]) {return _join(expr);}

any_syllable = expr:(onset nucleus coda? / consonantal_syllable) {return _join(expr);}

syllable = expr:(onset !y nucleus coda?) {return _join(expr);}

//// FIX: preventing {bla'ypre} from being a valid lujvo
consonantal_syllable = expr:(consonant syllabic &(consonantal_syllable / !nucleus onset) (consonant &spaces)?) {return _join(expr);}

coda = expr:(!any_syllable consonant &any_syllable / syllabic? consonant? &pause) {return _join(expr);}

onset = expr:(h / glide / initial) {return _join(expr);}

nucleus = expr:(vowel / diphthong / y !nucleus) {return _join(expr);}

//_________________________________________________________________

glide = expr:(i / u) &nucleus !glide {return expr;}

//diphthong = expr:(a u !u / (a i / e i / o i) !i) !nucleus {return _join(expr);}
diphthong = expr:(a i / a u / e i / o i) !nucleus !glide {return _join(expr);}

vowel = expr:(a / e / i / o / u) !nucleus {return expr;}

a = comma* [aA] {return "a";}

e = comma* [eE] {return "e";}

i = comma* [iI] {return "i";}

o = comma* [oO] {return "o";}

u = comma* [uU] {return "u";}

y = comma* [yY] {return "y";}


//___________________________________________________________________

cluster = expr:(consonant consonant+) {return _join(expr);}

initial_pair = expr:(&initial consonant consonant !consonant) {return _join(expr);}

initial = expr:(affricate / sibilant? other? liquid?) !consonant !glide {return _join(expr);}

affricate = expr:(t c / t s / d j / d z) {return _join(expr);}

liquid = expr:(l / r) {return _join(expr);}

other = expr:(p / t !l / k / q / f / x / b / d !l / g / v / m / n !liquid) {return _join(expr);}

sibilant = expr:(c / s !x / (j / z) !n !liquid) {return _join(expr); }

consonant = expr:(voiced / unvoiced / syllabic) {return expr;}

syllabic = expr:(l / m / n / r) {return expr;}

voiced = expr:(b / d / g / j / v / z) {return expr;}

unvoiced = expr:(c / f / k / p / s / t / x) {return expr;}

l = comma* [lL] !h !glide !l {return "l";}

m = comma* [mM] !h !glide !m !z {return "m";}

n = comma* [nN] !h !glide !n !affricate  {return "n";}

r = comma* [rR] !h !glide !r {return "r";}

b = comma* [bB] !h !glide !b !unvoiced {return "b";}

d = comma* [dD] !h !glide !d !unvoiced {return "d";}

g = comma* [gG] !h !glide !g !unvoiced {return "g";}

v = comma* [vV] !h !glide !v !unvoiced {return "v";}

j = comma* [jJ] !h !glide !j !z !unvoiced {return "j";}

z = comma* [zZ] !h !glide !z !j !unvoiced {return "z";}

s = comma* [sS] !h !glide !s !c !voiced {return "s";}

c = comma* [cC] !h !glide !c !s !x !voiced {return "c";}

x = comma* [xX] !h !glide !x !c !k !voiced {return "x";}

k = comma* [kK] !h !glide !k !x !voiced {return "k";}

q = comma* [qQ] !h !q {return "q";}

f = comma* [fF] !h !glide !f !voiced {return "f";}

p = comma* [pP] !h !glide !p !voiced {return "p";}

t = comma* [tT] !h !glide !t !voiced {return "t";}

h = comma* ['h] &nucleus {return "'";}

H = comma* ['h] &nucleus {return "'";}

//H = comma* (['hiI]) &nucleus {return "'";}

Ih = comma* (['hiI]) {return "'";}

//___________________________________________________________________

digit = expr:(comma* [0123456789] !h !nucleus) {return _join(expr);}

//post_word = expr:(pause / !i !u !(nucleus) lojban_word)  {return _join(expr);}
post_word = expr:(pause / !nucleus !slinkuhi !cmevla lojban_word)  {return _join(expr);}

pause = expr:(comma* space_char+ / EOF)  {return _join(expr);}

EOF = expr:(comma* !.)  {return _join(expr);}

comma = [,] {return "";}

non_lojban_word = expr:(!lojban_word non_space+)  {return _join(expr);}

non_space = expr:(!space_char .) {return _join(expr);}

//Unicode_style and escaped chars not compatible with cl_peg
space_char = [.\t\n\r?!\u0020] {return "";}

// space_char = [.?! ] / space_char1 / space_char2 
// space_char1 = '	'
// space_char2 = ''

//___________________________________________________________________

spaces = expr:(!Y initial_spaces)  {return _join(expr);}

initial_spaces = expr:((comma* space_char / !ybu Y)+ EOF? / EOF)  {return _join(expr);}

ybu = expr:(Y space_char* BU)  {return "ybu";}

lujvo = expr:(!gismu !fuhivla brivla)  {return _node("lujvo", expr);}

//___________________________________________________________________


A = &cmavo expr:( a / e / j i / o / u ) &post_word {return ["A", _join(expr)];}

BAI = &cmavo expr:( k a H a / d u H o / s i H u / z a u / k i H i / d u H i / c u H u / t u H i / t i H u / d i H o / j i H u / r i H a / n i H i / m u H i / k i H u / v a Ih u / k o i / c a Ih i / t a Ih i / p u H e / j a Ih i / k a i / b a i / f i H e / d e Ih i / c i H o / m a u / m u H u / r i H i / r a Ih i / k a H a i / p a Ih u / p a H a / l e H a / k u H u / t a i / b a u / m a Ih i / c i H e / f a u / p o Ih i / c a u / m a H e / c i H u / r a H a / p u H a / l i H e / l a Ih u / b a Ih i / k a Ih i / s a u / f a H e / b e Ih i / t i H i / j a H e / g a H a / v a H o / j i H o / m e H a / d o H e / j i H e / p i H o / g a u / z u H e / m e H e / r a i / x a u ) &post_word {return ["BAI", _join(expr)];}

BAhE = &cmavo expr:( b a H e / z a H e / p e H e / n u H i) &post_word {return ["BAhE", _join(expr)];}

BE = &cmavo expr:( b e ) &post_word  {return ["BE", _join(expr)];}

BEI = &cmavo expr:( b e i ) &post_word {return ["BEI", _join(expr)];}

BEhO = &cmavo expr:( b e H o ) &post_word {return ["BEhO", _join(expr)];}

//BIhE = &cmavo expr:( b i H e ) &post_word {return ["BIhE", _join(expr)];}

BIhI = &cmavo expr:( m i H i / b i H o / b i H i ) &post_word {return ["BIhI", _join(expr)];}

BO = &cmavo expr:( b o / b i H e ) &post_word  {return ["BO", _join(expr)];}

BOI = &cmavo expr:( b o i ) &post_word {return ["BOI", _join(expr)];}

BU = &cmavo expr:( b u ) &post_word {return ["BU", _join(expr)];}

//// EXP-MODIF: Adding .uy and .iy (Selpa'i)
BY = &cmavo expr:(ybu / j o H o / r u H o / g e H o / j e H o / l o H a / n a H a / s e H e / t o H a / g a H e / y h y / b y / c y / d y / f y / g y / j y / k y / l y / m y / n y / p y / r y / s y / t y / v y / x y / z y / u y / i y ) &post_word {return ["BY", _join(expr)];}

CAhA = &cmavo expr:( c a H a / p u H i / n u H o / k a H e / b i H a i) &post_word {return ["CAhA", _join(expr)];}

CEI = &cmavo expr:( c e i ) &post_word {return ["CEI", _join(expr)];}

CEhE = &cmavo expr:( c e H e ) &post_word {return ["CEhE", _join(expr)];}

CO = &cmavo expr:( c o ) &post_word {return ["CO", _join(expr)];}

//// EXP-ADD: di'ai, co'oi, ki'ai, sa'ei
COI = &cmavo expr:(  d o i / d a H o i / d i H a i / a H o i / c o H o i / k i H a i / s a H e i / j u H i / c o i / f i H i / t a H a / m u H o / f e H o / c o H o / p e H u / k e H o / n u H e / r e Ih i / b e H e / j e H e / m i H e / k i H e / v i H o ) &post_word {return ["COI", _join(expr)];}

CU = &cmavo expr:( c u ) &post_word {return ["CU", _join(expr)];}

CUhE = &cmavo expr:( c u H e / n a u ) &post_word {return ["CUhE", _join(expr)];}

DOhU = &cmavo expr:( d o H u ) &post_word {return ["DOhU", _join(expr)];}

FA = &cmavo expr:( f a i / f a / f e / f o / f u / f i H a / f i ) &post_word {return ["FA", _join(expr)];}

fa = &cmavo expr:( f a ) &post_word {return ["FA", _join(expr)];}
fe = &cmavo expr:( f e ) &post_word {return ["FE", _join(expr)];}
fi = &cmavo expr:( f i ) &post_word {return ["FI", _join(expr)];}
fo = &cmavo expr:( f o ) &post_word {return ["FO", _join(expr)];}
fu = &cmavo expr:( f u ) &post_word {return ["FU", _join(expr)];}


FAhA = &cmavo expr:( d u H a / b e H a / n e H u / v u H a / g a Ih u / t i H a / n i H a / c a Ih u / z u H a / r i H u / r u H u / r e H o / t e H e / b u H u / n e H a / p a H o / n e Ih i / t o H o / z o Ih i / z e H o / z o H a / f a H a ) &post_word {return ["FAhA", _join(expr)];}

FAhO = &cmavo expr:( f a H o ) &post_word {return ["FAhO", _join(expr)];}

FEhU = &cmavo expr:( f e H u ) &post_word {return ["FEhU", _join(expr)];}

FIhO = &cmavo expr:( f i H o ) &post_word {return ["FIhO", _join(expr)];}

FOI = &cmavo expr:( f o i ) &post_word {return ["FOI", _join(expr)];}

FUhA = &cmavo expr:( f u H a ) &post_word {return ["FUhA", _join(expr)];}

FUhE = &cmavo expr:( f u H e ) &post_word {return ["FUhE", _join(expr)];}

FUhO = &cmavo expr:( f u H o ) &post_word {return ["FUhO", _join(expr)];}

GA = &cmavo expr:( g e Ih i / g e / g o / g a / g u ) &post_word {return ["GA", _join(expr)];}

GAhO = &cmavo expr:( k e Ih i / g a H o ) &post_word {return ["GAhO", _join(expr)];}

GEhU = &cmavo expr:( g e H u ) &post_word {return ["GEhU", _join(expr)];}

GI = &cmavo expr:( g i ) &post_word {return ["GI", _join(expr)];}

GIhA = &cmavo expr:( g i H e / g i H i / g i H o / g i H a / g i H u ) &post_word {return ["GIhA", _join(expr)];}

GIhA_elided = {return ["GIhA", "GIhE"];}

GOI = &cmavo expr:( n o H u / n e / g o i / p o H u / p e / p o H e / p o ) &post_word {return ["GOI", _join(expr)];}

GOhA = &cmavo expr:( m o / n e i / g o H u / g o H o / g o Ih i / n o H a / g o H e / g o H a / d u / b u H a / b u H e / b u H i / c o H e ) &post_word {return ["GOhA", _join(expr)];} 

GOhOI = &cmavo expr:( z e h o i / t a h a i / g o h o i ) &post_word {return ["GOhOI", _join(expr)];}

GUhA = &cmavo expr:( g u H e / g u H i / g u H o / g u H a / g u H u ) &post_word {return ["GUhA", _join(expr)];}

I = &cmavo expr:( i ) &post_word {return ["I", _join(expr)];}

IAU = &cmavo expr:( i H a u / i a u ) &post_word {return ["IAU", _join(expr)];}

JA = &cmavo expr:( j e Ih i / j e / j o / j a / j u ) &post_word { return ["JA", _join(expr)];} 

JAI = &cmavo expr:( j a i ) &post_word {return ["JAI", _join(expr)];}

JOhI = &cmavo expr:( j o Ih i ) &post_word {return ["JOhI", _join(expr)];}

JOI = &cmavo expr:( f a Ih u / p i H u / j o i / c e H o / c e / j o H u / k u H a / j o H e / j u H e ) &post_word {return ["JOI", _join(expr)];}

KE = &cmavo expr:( k e / p i H a i / n u H i ) &post_word {return ["KE", _join(expr)];}

KEhE = &cmavo expr:( k e H e) &post_word {return ["KEhE", _join(expr)];}

KEI = &cmavo expr:( k e i ) &post_word {return ["KEI", _join(expr)];}

KI = &cmavo expr:( k i ) &post_word {return ["KI", _join(expr)];}

KOhA = &cmavo expr:( z u H a i / d a Ih u / d a H e / d i H u / d i H e / d e H u / d e H e / d e i / d o Ih i / m i H o / m i H a i / m a H a / m i H a / d o H o / k o H a / f o H u / k o H e / k o Ih i / k o H o / k o H u / f o H a / f o H e / f o Ih i / f o H o / v o H a / v o H e / v o Ih i / v o H o / v o H u / r u / r i / r a / t a / t u / t i / z i H o / k e H a / m a / z u H i / z o H e / c e H u / d a / d e / d i / k o / m i / d o / x a i) &post_word { return ["KOhA", _join(expr)];}

KU = &cmavo expr:( k u ) &post_word {return ["KU", _join(expr)];}

KUhE = &cmavo expr:( k u H e ) &post_word {return ["KUhE", _join(expr)];}

KUhO = &cmavo expr:( k u H o ) &post_word {return ["KUhO", _join(expr)];}

//// EXP-DELETION: brivla/cmevla merge
// LA = &cmavo expr:( l a i / l a Ih i / l a ) &post_word { return ["LA", _join(expr)]; }

LAU = &cmavo expr:( c e H a / l a u / z a i / t a u ) &post_word {return ["LAU", _join(expr)];}

//// EXP-ADD: zo'ei
LAhE = &cmavo expr:( z o H e i / t u H a / l u H a / l u H o / l a H e / v u H i / l u H i / l u H e ) &post_word {return ["LAhE", _join(expr)];}

//// EXP-MODIF: brivla/cmevla merge + add of me'ei
LE = &cmavo expr:( m e H e i / l e i / l o i / l e Ih i / l o Ih i / l e H e / l o H e / l o / l e / l a i / l a Ih i / l a ) &post_word { return ["LE", _join(expr)];}

// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
LEhAI = &cmavo expr:( l e H a i ) &post_word {return ["LEhAI", _join(expr)];}

LEhU = &cmavo expr:( l e H u ) &post_word {return ["LEhU", _join(expr)];}

LI = &cmavo expr:( l i H a i / m e H o / l i ) &post_word {return ["LI", _join(expr)];}

LIhU = &cmavo expr:( l i H u ) &post_word {return ["LIhU", _join(expr)];}

// EXP-MODIF: attempt to formalize lo'ai..sa'ai..le'ai replacement expressions
LOhAI = &cmavo expr:( l o H a i / s a H a i ) &post_word {return ["LOhAI", _join(expr)];}

LOhO = &cmavo expr:( l o H o ) &post_word {return ["LOhO", _join(expr)];}

LOhU = &cmavo expr:( l o H u ) &post_word {return ["LOhU", _join(expr)];}

LU = &cmavo expr:( l u ) &post_word {return ["LU", _join(expr)];}

LUhU = &cmavo expr:( l u H u ) &post_word {return ["LUhU", _join(expr)];}

MAI = &cmavo expr:( m o H o / m a i ) &post_word {return ["MAI", _join(expr)];}

//// EXP-ADD: me'au
ME = &cmavo expr:(m e H a u / m e) &post_word {return ["ME", _join(expr)];}

MEhU = &cmavo expr:( m e H u ) &post_word {return ["MEhU", _join(expr)];}

MOhE = &cmavo expr:( m o H e / n i H e ) &post_word {return ["MOhE", _join(expr)];}

MOI = &cmavo expr:( m e i / m o i / s i H e / c u H o / v a H e ) &post_word {return ["MOI", _join(expr)];}

NA = &cmavo expr:( j a H a / n a ) &post_word {return ["NA", _join(expr)];}

MAhO = &cmavo expr:( n a Ih u / m a H o) &post_word {return ["MAhO", _join(expr)];}

NIhO = &cmavo expr:( n i H o / n o Ih i ) &post_word {return ["NIhO", _join(expr)];}

NOI = &cmavo expr:( v o i / n o i / p o i ) &post_word {return ["NOI", _join(expr)];}

//// EXP-ADD: poi'i, kai'u
NU = &cmavo expr:(p o i H i / k a i H u / n i / d u H u / s i H o / n u / l i H i / k a / j e i / s u H u / z u H o / m u H e / p u H u / z a Ih i ) &post_word {return ["NU", _join(expr)];}

NUhA = &cmavo expr:( n u H a ) &post_word {return ["NUhA", _join(expr)];}

NUhI = &cmavo expr:( n u H i ) &post_word {return ["NUhI", _join(expr)];}

NUhU = &cmavo expr:( n u H u ) &post_word {return ["NUhU", _join(expr)];}

//// EXP-ADD: xo'e
PA = &cmavo expr:( x o H e / d a u / f e i / g a i / j a u / x e i / r e i / v a i / p i H e / p i / f i H u / z a Ih u / m e Ih i / n i H u / k i H o / c e Ih i / m a Ih u / r a H e / d a H a / s o H a / j i H i / s u H o / s u H e / r o / r a u / s o H u / s o Ih i / s o H e / s o H o / m o H a / d u H e / t e H o / k a H o / c i H i / t u H o / x o / p a i / n o H o / n o / p a / r e / c i / v o / m u / x a / z e / b i / s o / digit ) &post_word {return ["PA", _join(expr)];}

PEhE = &cmavo expr:( p e H e ) &post_word {return ["PEhE", _join(expr)];}

PEhO = &cmavo expr:( p e H o ) &post_word {return ["PEhO", _join(expr)];}

PU = &cmavo expr:( b a / p u / c a ) &post_word {return ["PU", _join(expr)];}

RAhO = &cmavo expr:( r a H o ) &post_word {return ["RAhO", _join(expr)];}

RAhOI = &cmavo expr:( r a H o i ) &post_word {return ["RAhOI", _join(expr)];}

//// EXP-ADD: mu'ei
ROI = &cmavo expr:( r e H u / r o i / m u H e i ) &post_word {return ["ROI", _join(expr)];}

SE = &cmavo expr:( s e / t e / v e / x e / t o H a i / v o H a i / x o H a i / s u H e i / s u H a i ) &post_word {return ["SE", _join(expr)];}

SEI = &cmavo expr:( s e i / t i H o ) &post_word {return ["SEI", _join(expr)];}

SEhU = &cmavo expr:( s e H u ) &post_word {return ["SEhU", _join(expr)];}

SI = &cmavo expr:( z e H e i / z e i / s i H u H i / s i ) &post_word {return ["SI", _join(expr)];}

SOI = &cmavo expr:( s o i / x o i / f i H o i ) &post_word {return ["SOI", _join(expr)];}

SU = &cmavo expr:( s u / l i H o i ) &post_word {return ["SU", _join(expr)];}

TAhE = &cmavo expr:( z e i H a / d e i H a / r u H i / t a H e / d i H i / n a H o ) &post_word {return ["TAhE", _join(expr)];}

TEhU = &cmavo expr:( t e H u ) &post_word {return ["TEhU", _join(expr)];}

TEI = &cmavo expr:( t e i ) &post_word {return ["TEI", _join(expr)];}

TO = &cmavo expr:( t o Ih i / t o ) &post_word {return ["TO", _join(expr)];}

TOI = &cmavo expr:( t o i ) &post_word {return ["TOI", _join(expr)];}

TUhE = &cmavo expr:( t u H e ) &post_word {return ["TUhE", _join(expr)];}

TUhU = &cmavo expr:( t u H u ) &post_word {return ["TUhU", _join(expr)];}

UI = &cmavo expr:( d a H o / f u H a u / k o H o i / s i H a u / o H a i / x e H e / i H a / i e / a H e / u H i / i H o / i H e / a H a / i a / o Ih i / o H e / e H e / o i / u o / e Ih i / u H o / a u / u a / a Ih i / i H u / i i / u H a / u i / a H o / a i / a Ih u / i u / e i / o H o / e H a / u u / o H a / o H u / u H u / e H o / i o / e H u / u e / i H i / u H e / b a H a / j a H o / c a H e / s u H a / t i H e / k a Ih u / s e H o / z a H a / p e Ih i / r u H a / j u H a / t a H o / r a Ih u / l i H a / b a Ih u / m u H a / d o H a / t o H u / v a Ih i / p a H e / z u H u / s a H e / l a H a / k e H u / s a Ih u / d a Ih i / j e H u / s a H a / t a Ih u / b i H u / l i H o / p a u / m i H u / k u H i / j i H a / s i H a / p o H o / p e H a / l e H o / j u H o/ g a Ih i / v u H e / k i H a / x u / g e H e / s a / b i H a / z i H a) &post_word {return ["UI", _join(expr)];}

DAI = &cmavo expr:( k a u / d a i / s e Ih i / p e i / b u H o / n a Ih i / j o H a / r o Ih i / r o H e / r o H o / r o H u / r o H a / r e H e / z o H o / x o H o  / f u H i  / b e H u / r i H e / s e H a) &post_word {return ["DAI", _join(expr)];}

JUhA_elided = &post_word {return ["JUhA elided", "JUhA"];}

CAI = &cmavo expr:( n a i / j a H a i / c a i / c u H i / s a i / r u H e / m a u H i / d a u H i / m e H a i ) &post_word {return ["CAI", _join(expr)];}

NAhE = &cmavo expr:( s a i H e / r e i H e / n o i H e / m o Ih i / f e H e / n a H e i / t o H e / j e H a / n a H e / n o H e ) &post_word {return ["NAhE", _join(expr)];}

VA = &cmavo expr:( v i / v a / v u ) &post_word {return ["VA", _join(expr)];}

VAU = &cmavo expr:( v a u ) &post_word {return ["VAU", _join(expr)];}

VEI = &cmavo expr:( v e i ) &post_word {return ["VEI", _join(expr)];}

VEhO = &cmavo expr:( v e H o ) &post_word {return ["VEhO", _join(expr)];}

VUhU = &cmavo expr:( g e H a / f u H u / p i H i / f e Ih i / v u H u / s u H i / j u H u / g e i / p a Ih i / f a Ih i / t e H a / c u H a / v a H a / n e H o / d e H o / f e H a / s a H o / r e H a / r i H o / s a Ih i / p i H a / s i H i ) &post_word {return ["VUhU", _join(expr)];}

VEhA = &cmavo expr:( v e H u / v e H a / v e Ih i / v e H e ) &post_word {return ["VEhA", _join(expr)];}

VIhA = &cmavo expr:( v i H i / v i H a / v i H u / v i H e ) &post_word {return ["VIhA", _join(expr)];}

VUhO = &cmavo expr:( v u H o ) &post_word {return ["VUhO", _join(expr)];}

XI = &cmavo expr:( x i / t e H a i ) &post_word {return ["XI", _join(expr)];}

Y = &cmavo expr:( y+ ) &post_word {return _join(expr);}

ZAhO = &cmavo expr:( c o Ih i / p u H o / c o H u / m o H u / c a H o / c o H a / d e H a / b a H o / d i H a / z a H o / x a H o ) &post_word {return ["ZAhO", _join(expr)];}

ZEhA = &cmavo expr:( z e H u / z e H a / z e Ih i / z e H e ) &post_word {return ["ZEhA", _join(expr)];}

ZEI = &cmavo expr:( z e i ) &post_word {return ["ZEI", _join(expr)];}

ZI = &cmavo expr:( z u / z a / z i ) &post_word {return ["ZI", _join(expr)];}

ZIhE = &cmavo expr:( z i H e ) &post_word {return ["ZIhE", _join(expr)];}

//// EXP-ADD: ma'oi
ZO = &cmavo expr:( z o / m a H o i ) &post_word {return ["ZO", _join(expr)];}

ZOI = &cmavo expr:( z o i / l a H o ) &post_word {return ["ZOI", _join(expr)];}

//// EXP-ADD: ce'ai
ZOhU = &cmavo expr:( c e H a i / z o H u ) &post_word {return ["ZOhU", _join(expr)];}

// ___ EXPERIMENTAL SELMAHO ___ //

ZOhOI = &cmavo expr:( z o H o i / l a H o i ) &post_word {return ["ZOhOI", _join(expr)];}
MEhOI = &cmavo expr:( m e H o i ) &post_word {return ["ZOhOI", _join(expr)];}
NOhOI = &cmavo expr:( n o H o i / p o H o i ) &post_word {return ["NOhOI", _join(expr)];}
KUhOI = &cmavo expr:( k u H o i ) &post_word {return ["KUhOI", _join(expr)];}